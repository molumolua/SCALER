{
    "1003_F. Abbreviation": {
        "name": "1003_F. Abbreviation",
        "logic_description": "You are given a text consisting of n space-separated words. There is exactly one space character between any pair of adjacent words. There are no spaces before the first word and no spaces after the last word. The length of text is the number of letters and spaces in it. w_i is the i-th word of text. All words consist only of lowercase Latin letters.\n\nLet's denote a segment of words w[i..j] as a sequence of words w_i, w_{i + 1}, ..., w_j. Two segments of words w[i_1 .. j_1] and w[i_2 .. j_2] are considered equal if j_1 - i_1 = j_2 - i_2, j_1 ≥ i_1, j_2 ≥ i_2, and for every t ∈ [0, j_1 - i_1] w_{i_1 + t} = w_{i_2 + t}. For example, for the text \"to be or not to be\" the segments w[1..2] and w[5..6] are equal, they correspond to the words \"to be\".\n\nAn abbreviation is a replacement of some segments of words with their first uppercase letters. In order to perform an abbreviation, you have to choose at least two non-intersecting equal segments of words, and replace each chosen segment with the string consisting of first letters of the words in the segment (written in uppercase). For example, for the text \"a ab a a b ab a a b c\" you can replace segments of words w[2..4] and w[6..8] with an abbreviation \"AAA\" and obtain the text \"a AAA b AAA b c\", or you can replace segments of words w[2..5] and w[6..9] with an abbreviation \"AAAB\" and obtain the text \"a AAAB AAAB c\".\n\nWhat is the minimum length of the text after at most one abbreviation?",
        "raw_description": "You are given a text consisting of n space-separated words. There is exactly one space character between any pair of adjacent words. There are no spaces before the first word and no spaces after the last word. The length of text is the number of letters and spaces in it. w_i is the i-th word of text. All words consist only of lowercase Latin letters.\n\nLet's denote a segment of words w[i..j] as a sequence of words w_i, w_{i + 1}, ..., w_j. Two segments of words w[i_1 .. j_1] and w[i_2 .. j_2] are considered equal if j_1 - i_1 = j_2 - i_2, j_1 ≥ i_1, j_2 ≥ i_2, and for every t ∈ [0, j_1 - i_1] w_{i_1 + t} = w_{i_2 + t}. For example, for the text \"to be or not to be\" the segments w[1..2] and w[5..6] are equal, they correspond to the words \"to be\".\n\nAn abbreviation is a replacement of some segments of words with their first uppercase letters. In order to perform an abbreviation, you have to choose at least two non-intersecting equal segments of words, and replace each chosen segment with the string consisting of first letters of the words in the segment (written in uppercase). For example, for the text \"a ab a a b ab a a b c\" you can replace segments of words w[2..4] and w[6..8] with an abbreviation \"AAA\" and obtain the text \"a AAA b AAA b c\", or you can replace segments of words w[2..5] and w[6..9] with an abbreviation \"AAAB\" and obtain the text \"a AAAB AAAB c\".\n\nWhat is the minimum length of the text after at most one abbreviation?\n\nInput\n\nThe first line of the input contains one integer n (1 ≤ n ≤ 300) — the number of words in the text.\n\nThe next line contains n space-separated words of the text w_1, w_2, ..., w_n. Each word consists only of lowercase Latin letters.\n\nIt is guaranteed that the length of text does not exceed 10^5.\n\nOutput\n\nPrint one integer — the minimum length of the text after at most one abbreviation.\n\nExamples\n\nInput\n\n6\nto be or not to be\n\n\nOutput\n\n12\n\n\nInput\n\n10\na ab a a b ab a a b c\n\n\nOutput\n\n13\n\n\nInput\n\n6\naa bb aa aa bb bb\n\n\nOutput\n\n11\n\nNote\n\nIn the first example you can obtain the text \"TB or not TB\".\n\nIn the second example you can obtain the text \"a AAAB AAAB c\".\n\nIn the third example you can obtain the text \"AB aa AB bb\".",
        "solutions": {
            "solution": [
                "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst int N = 300 + 5;\nmap<string, int> Map;\nint id[N], w[N], a[N], p[N];\nvoid getNext(int a[], int n) {\n  p[0] = -1;\n  int j = -1;\n  for (int i = 1; i < n; i++) {\n    while (j != -1 && a[j + 1] != a[i]) j = p[j];\n    if (a[j + 1] == a[i]) j++;\n    p[i] = j;\n  }\n}\nint KMP(int a[], int n, int b[], int m) {\n  int ret = 0;\n  int j = -1;\n  for (int i = 0; i < m; i++) {\n    while (j != -1 && a[j + 1] != b[i]) j = p[j];\n    if (a[j + 1] == b[i]) j++;\n    if (j == n - 1) {\n      ret++;\n      j = -1;\n    }\n  }\n  return ret;\n}\nint main() {\n  int n;\n  cin >> n;\n  int idx = 0;\n  for (int i = 1; i <= n; i++) {\n    string s;\n    cin >> s;\n    id[i] = Map[s];\n    if (!id[i]) id[i] = Map[s] = ++idx;\n    w[i] = s.size() + w[i - 1];\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; i++)\n    for (int j = i; j <= n; j++) {\n      for (int k = i; k <= j; k++) a[k - i] = id[k];\n      getNext(a, j - i + 1);\n      int s = KMP(a, j - i + 1, id + 1, n);\n      if (s > 1) ans = max(ans, (w[j] - w[i - 1] - 1) * s);\n    }\n  cout << w[n] + n - 1 - ans;\n  return 0;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 10;\nvector<long long> arr;\nint sz[N];\nlong long compute_hash(string const& s) {\n  const int p = 31;\n  const int m = 1e9 + 9;\n  long long hash_value = 0;\n  long long p_pow = 1;\n  for (char c : s) {\n    hash_value = (hash_value + (c - 'a' + 1) * p_pow) % m;\n    p_pow = (p_pow * p) % m;\n  }\n  return hash_value;\n}\nint pi[N];\nint ans = 0, sum = 0;\nint tcnt = 0;\nvoid prefix_function(vector<long long> v) {\n  vector<long long> s = v;\n  int m = v.size();\n  s.push_back(-1);\n  for (auto i : arr) s.push_back(i);\n  int n = s.size();\n  pi[0] = 0;\n  for (int i = 1; i < n; i++) {\n    int j = pi[i - 1];\n    while (j > 0 && s[i] != s[j]) j = pi[j - 1];\n    if (s[i] == s[j]) j++;\n    pi[i] = j;\n  }\n  int curr_ans = sum;\n  int cnt = 0;\n  for (int i = m + 1; i < n; ++i) {\n    if (pi[i] == m) {\n      curr_ans -= (sz[i - m] - sz[i - 2 * m]);\n      ++curr_ans;\n      ++cnt;\n      i += (m - 1);\n    }\n  }\n  if (cnt > 1) ans = min(ans, curr_ans);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n;\n  cin >> n;\n  sz[0] = 0;\n  for (int i = 0; i < n; ++i) {\n    string s;\n    cin >> s;\n    arr.push_back(compute_hash(s));\n    sz[i + 1] = sz[i] + (int)s.length();\n    sum += s.length();\n  }\n  sum += (n - 1);\n  ans = sum;\n  vector<long long> v;\n  for (int i = 0; i < arr.size(); ++i) {\n    for (int j = i; j < arr.size(); ++j) {\n      v.push_back(arr[j]);\n      prefix_function(v);\n      ++tcnt;\n    }\n    v.clear();\n  }\n  cout << ans << endl;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nint const maxn = 305;\nmap<string, int> mmp;\nvector<pair<int, int> > p;\nvector<int> num[maxn];\nint main() {\n  int n, cnt, tot = 0, maxlen = 0, res;\n  scanf(\"%d\", &n);\n  res = n - 1;\n  string second;\n  for (int i = 0; i < n; i++) {\n    cin >> second;\n    if (!mmp[second]) mmp[second] = ++tot;\n    cnt = mmp[second];\n    p.push_back(pair<int, int>(cnt, second.size()));\n    num[cnt].push_back(i);\n    res += second.size();\n  }\n  for (int i = 1; i <= tot; i++) {\n    int len = num[i].size();\n    if (len == 1) continue;\n    maxlen = max(maxlen, (p[num[i][0]].second - 1) * len);\n    for (int j = 0; j < len; j++) {\n      int l = num[i][j];\n      for (int k = 1; l + k < n; k++) {\n        int tmp = p[l].second - 1, pre = l + k, sum = 0;\n        for (int x = 1; x <= k; x++) tmp += p[l + x].second;\n        for (int x = j + 1; x < len; x++) {\n          int r = num[i][x];\n          if (r > pre && r + k < n) {\n            bool flag = 1;\n            for (int y = 1; y <= k; y++)\n              if (p[l + y] != p[r + y]) {\n                flag = 0;\n                break;\n              }\n            if (flag) {\n              sum++;\n              pre = r + k;\n            }\n          }\n        }\n        if (sum) maxlen = max(maxlen, tmp * (sum + 1));\n      }\n    }\n  }\n  printf(\"%d\\n\", res - maxlen);\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, p[303];\npair<long long, long long> hsh[303][303];\nlong long s, ans;\nstring w[303];\nvoid solve() {\n  cin >> n;\n  for (long long i = 0; i < n; i++) {\n    cin >> w[i];\n    p[i] = (long long)w[i].size();\n    if (i) {\n      p[i] += p[i - 1];\n    }\n  }\n  s = p[n - 1] + n - 1;\n  ans = s;\n  for (long long i = 0; i < n; i++) {\n    long long cur = 0, cur2 = 0;\n    for (long long j = i; j < n; j++) {\n      for (auto r : w[j]) {\n        cur = (cur * 31 + r - 'a' + 1) % 1000000007;\n        cur2 = (cur2 * 67 + r - 'a' + 1) % 1000000009;\n      }\n      hsh[i][j] = {cur, cur2};\n      cur = (cur * 31 + '#' - 'a' + 1) % 1000000007;\n      cur2 = (cur2 * 67 + '#' - 'a' + 1) % 1000000009;\n    }\n  }\n  for (long long i = 0; i < n; i++) {\n    for (long long j = i; j < n; j++) {\n      long long l = j - i, cnt = 1;\n      for (long long k = j + 1; k < n; k++) {\n        if (k + l >= n) break;\n        if (hsh[k][k + l] == hsh[i][j]) {\n          cnt++;\n          k = k + l;\n        }\n      }\n      if (cnt < 2) continue;\n      long long d = p[j] - (i ? p[i - 1] : 0);\n      ans = min(ans, s - cnt * (d - 1));\n    }\n  }\n  cout << ans << '\\n';\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 305;\nint n;\nstring s[MAXN];\nsize_t c[MAXN];\nint pre[MAXN];\nint dp[MAXN][MAXN];\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    cin >> s[i];\n    c[i] = hash<string>()(s[i]);\n    pre[i] = pre[i - 1] + s[i].length();\n  }\n  for (int i = n - 1; i > 0; i--)\n    for (int j = n; j > i; j--)\n      if (c[i] == c[j]) dp[i][j] = dp[i + 1][j + 1] + 1;\n  int ans = pre[n] + n - 1;\n  for (int i = 1; i < n; i++)\n    for (int l = 1; l <= n - i + 1; l++) {\n      int cnt = 1;\n      for (int j = i + l; j <= n; j++)\n        if (dp[i][j] >= l) {\n          cnt++;\n          j += l - 1;\n        }\n      if (cnt > 1)\n        ans =\n            min(ans, pre[n] + n - 1 - cnt * (pre[i + l - 1] - pre[i - 1] - 1));\n    }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod = 1e9 + 7;\nlong long INF = 1e7;\ndouble EPS = 1e-12;\ndouble tick() {\n  static clock_t oldt;\n  clock_t newt = clock();\n  double diff = 1.0 * (newt - oldt) / CLOCKS_PER_SEC;\n  oldt = newt;\n  return diff;\n}\nlong long int powP(long long int a, long long int b) {\n  if (b == 0) return 1 % mod;\n  long long int k;\n  k = powP(a, b / 2);\n  k = k * k % mod;\n  if (b % 2 == 0)\n    return k;\n  else\n    return a * k % mod;\n}\nbool bitSet(long long int n, long long int i) {\n  if ((n & (1LL << i)) != 0)\n    return true;\n  else\n    return false;\n}\nlong long int findGcd(long long int a, long long int b) {\n  if (a == 0)\n    return b;\n  else\n    return findGcd(b % a, a);\n}\nstring S[300010];\nlong long int A[300010], B[300010], C[300010];\nmap<string, vector<long long int> > M;\nbool dp[503][503];\nlong long int Next[503][503], Reduce[503][503], Total[503][503];\nint main() {\n  long long int T, i, p, j, l, n, e, r, b, c, k, m, q, a, d, w, x, y, u, v, z,\n      t, curr, prev, sum, ans, pos, val, countA, indicator;\n  scanf(\"%lld\", &n);\n  for (long long int i = (1); i <= (n); ++i) {\n    cin >> S[i];\n    A[i] = S[i].size();\n    A[i] += A[i - 1];\n    M[S[i]].push_back(i);\n  }\n  for (const auto& i : M) {\n    for (const auto& a : i.second) {\n      for (const auto& b : i.second) {\n        dp[a][b] = dp[b][a] = true;\n      }\n    }\n  }\n  for (long long int i = (1); i <= (n); ++i)\n    for (long long int j = (i + 1); j <= (n); ++j) {\n      curr = 0;\n      while (i + curr < j and j + curr <= n and dp[i + curr][j + curr]) {\n        curr++;\n        if (Next[i][curr] == 0) {\n          Next[i][curr] = j;\n          Reduce[i][curr] = (A[i + curr - 1] - A[i - 1] + curr - 1) - curr;\n        }\n      }\n    }\n  ans = 0;\n  for (long long int i = (n); i >= (1); --i)\n    for (long long int curr = (1); curr <= (n); ++curr) {\n      if (Next[i][curr] == 0) continue;\n      Total[i][curr] += 1 + Total[Next[i][curr]][curr];\n      ans = max(ans, (1 + Total[i][curr]) * Reduce[i][curr]);\n    }\n  printf(\"%lld\\n\", A[n] + n - 1 - ans);\n  return 0;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  vector<int> cost;\n  map<string, int> mp;\n  mp[\" \"] = 0;\n  cost.push_back(1);\n  int len = 0;\n  vector<int> ar(2 * n - 1);\n  for (int i = 1; i < 2 * n - 1; i += 2) {\n    ar[i] = 0;\n    len += 1;\n  }\n  for (int i = 0; i < n; i++) {\n    string s;\n    cin >> s;\n    if (mp.find(s) == mp.end()) {\n      mp[s] = cost.size();\n      cost.push_back(s.size());\n    }\n    len += s.size();\n    ar[i * 2] = mp[s];\n  }\n  map<string, vector<pair<int, pair<int, int> > > > mp2[n];\n  for (int i = 0; i < 2 * n; i += 2) {\n    for (int j = i; j < 2 * n; j += 2) {\n      int sz = (j - i) / 2;\n      string s;\n      int cst = 0;\n      for (int k = i; k <= j; k += 2) {\n        s.append(to_string(ar[k]));\n        cst += cost[ar[k]];\n        if (k != j) {\n          s.append(string(\" \"));\n          cst += 1;\n        }\n      }\n      cst -= (sz + 1);\n      mp2[sz][s].push_back({cst, make_pair(i, j)});\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    for (auto &vector : mp2[i]) {\n      if (vector.second.size() > 1) {\n        int cst = vector.second[0].first;\n        int a[n];\n        for (int i = 0; i < n; i++) a[i] = -1;\n        for (int i = 0; i < vector.second.size(); i++) {\n          int l = vector.second[i].second.first / 2;\n          int r = vector.second[i].second.second / 2;\n          a[r] = (((l) > (a[r])) ? (l) : (a[r]));\n        }\n        int cur = -1, num = 0;\n        for (int i = 0; i < n; i++) {\n          if (a[i] != -1 && a[i] > cur) {\n            num++;\n            cur = i;\n          }\n        }\n        if (num > 1) {\n          ans = (((ans) > (cst * num)) ? (ans) : (cst * num));\n        }\n      }\n    }\n  }\n  cout << len - ans << \"\\n\";\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nclass Solution {\n public:\n  Solution() : _idx(), _a(), _c(), _len(), _total(-1) {}\n  void add_word(const string& s) {\n    _total += s.size() + 1;\n    int i = get_idx(s);\n    _a.push_back(i);\n    ++_c[i];\n  }\n  int solve() {\n    int n = _a.size(), r = 0;\n    for (int i = 0; i < n; ++i) {\n      if (_c[_a[i]] < 2) continue;\n      int s = _len[_a[i]] - 1;\n      r = max(r, _c[_a[i]] * s);\n      for (int j = i + 1; j < n; ++j) {\n        if (_c[_a[j]] < 2) break;\n        s += _len[_a[j]];\n        if (2 * j + 1 - i >= n) break;\n        int t = times(i, j + 1);\n        if (t > 1) r = max(r, s * t);\n      }\n    }\n    return _total - r;\n  }\n\n private:\n  int times(int a, int b) {\n    int m = b - a, n = _a.size();\n    vector<int> t(m + 1, 0);\n    t[0] = -1;\n    int i = 1, j = 0;\n    for (; i < m; ++i, ++j) {\n      if (_a[a + i] == _a[a + j]) {\n        t[i] = t[j];\n      } else {\n        t[i] = j;\n        while (j >= 0 && _a[a + i] != _a[a + j]) j = t[j];\n      }\n    }\n    t[m] = j;\n    int r = 1;\n    i = b;\n    j = 0;\n    while (i < n) {\n      if (_a[a + j] == _a[i]) {\n        ++i;\n        ++j;\n        if (j == m) {\n          j = 0;\n          ++r;\n        }\n      } else {\n        j = t[j];\n        if (j < 0) {\n          ++i;\n          ++j;\n        }\n      }\n    }\n    return r;\n  }\n  int get_idx(const string& s) {\n    auto it = _idx.find(s);\n    if (it != _idx.end()) return it->second;\n    int i = _len.size();\n    _idx[s] = i;\n    _len.push_back(s.size());\n    _c.push_back(0);\n    return i;\n  }\n\n private:\n  unordered_map<string, int> _idx;\n  vector<int> _a, _c, _len;\n  int _total;\n};\nint main() {\n  int n;\n  cin >> n;\n  Solution solution;\n  string s;\n  while (n--) {\n    cin >> s;\n    solution.add_word(s);\n  }\n  cout << solution.solve() << endl;\n  return 0;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nint read() {\n  int f = 1, x = 0;\n  char s = getchar();\n  while (s < '0' || s > '9') {\n    if (s == '-') f = -1;\n    s = getchar();\n  }\n  while (s >= '0' && s <= '9') {\n    x = x * 10 + s - '0';\n    s = getchar();\n  }\n  return x * f;\n}\nint len[300 + 5];\nstring str[300 + 5];\nbool vis[300 + 5][300 + 5];\nint main() {\n  int n = read(), Ans;\n  for (int i = 1; i <= n; i++) {\n    cin >> str[i];\n    len[i] = int(str[i].length()) + len[i - 1];\n  }\n  Ans = len[n] + n - 1;\n  for (int i = 1; i <= n; i++) {\n    for (int j = i; j <= n; j++) {\n      int tmp = 0;\n      if (vis[i][j]) continue;\n      vis[i][j] = 1;\n      for (int t = j + 1; t <= n - j + i; t++) {\n        bool flag = 0;\n        for (int s = 0; s <= j - i; s++)\n          if (str[i + s] != str[t + s]) {\n            flag++;\n            break;\n          }\n        if (!flag) tmp++, t += j - i, vis[t][t + j - i] = 1;\n      }\n      if (tmp != 0) {\n        int tot = len[n] - (tmp + 1) * (len[j] - len[i - 1]) + tmp + n;\n        Ans = min(Ans, tot);\n      }\n    }\n  }\n  printf(\"%d\\n\", Ans);\n  return 0;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nint in() {\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\nlong long lin() {\n  long long x;\n  scanf(\"%lld\", &x);\n  return x;\n}\nstruct RollingHash {\n  int n;\n  long long mod1 = 1e9 + 7, mod2 = 1e9 + 9;\n  long long base1 = 1007, base2 = 1019;\n  vector<long long> hash1, hash2, pow1, pow2;\n  void init(string s) {\n    n = s.length();\n    hash1.assign(n + 1, 0);\n    hash2.assign(n + 1, 0);\n    pow1.assign(n + 1, 1);\n    pow2.assign(n + 1, 1);\n    for (int i = 0; i < n; ++i) {\n      hash1[i + 1] = (hash1[i] * base1 + s[i]) % mod1;\n      hash2[i + 1] = (hash2[i] * base2 + s[i]) % mod2;\n      pow1[i + 1] = (pow1[i] * base1) % mod1;\n      pow2[i + 1] = (pow2[i] * base2) % mod2;\n    }\n  }\n  pair<long long, long long> hash(int l, int r) {\n    long long h1 = ((hash1[r] - hash1[l] * pow1[r - l]) % mod1 + mod1) % mod1;\n    long long h2 = ((hash2[r] - hash2[l] * pow2[r - l]) % mod2 + mod2) % mod2;\n    return pair<long long, long long>(h1, h2);\n  }\n  bool match(int l1, int r1, int l2, int r2) {\n    if (r1 > n || r2 > n) return false;\n    return hash(l1, r1) == hash(l2, r2);\n  }\n  bool match(int l1, int l2, int k) { return match(l1, l1 + k, l2, l2 + k); }\n  int lcp(int l1, int l2) {\n    int ok = 0, ng = n;\n    while (ng - ok > 1) {\n      int m = (ok + ng) / 2;\n      if (match(l1, l2, m))\n        ok = m;\n      else\n        ng = m;\n    }\n    return ok;\n  }\n};\nRollingHash rh;\nint len[310];\nint main() {\n  int n;\n  cin >> n;\n  vector<string> s(n);\n  for (int i = 0; i < n; ++i) cin >> s[i];\n  string t;\n  for (int i = 0; i < n; ++i) t += s[i];\n  vector<int> h(t.length() + 1, -1);\n  for (int i = 0; i < n; ++i) {\n    h[len[i]] = i;\n    len[i + 1] = len[i] + s[i].length();\n  }\n  h[len[n]] = n;\n  rh.init(t);\n  vector<vector<int> > same(n, vector<int>(n));\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < n; ++j) {\n      while (i + same[i][j] < n && j + same[i][j] < n &&\n             s[i + same[i][j]].length() == s[j + same[i][j]].length() &&\n             rh.match(len[i + same[i][j]], len[j + same[i][j]],\n                      s[i + same[i][j]].length())) {\n        same[i][j]++;\n      }\n    }\n  int ans = t.length() + n - 1, m = ans;\n  for (int l = 0; l < n; ++l)\n    for (int r = l + 1; r <= n; ++r) {\n      int x = r - l, d = len[r] - len[l], cnt = 0;\n      for (int i = 0; i < n; ++i) {\n        if (same[i][l] >= x) {\n          cnt++;\n          i = h[len[i] + d] - 1;\n        }\n      }\n      if (cnt > 1) {\n        ans = min(ans, m - cnt * (d - 1));\n      }\n    }\n  cout << ans << endl;\n  return 0;\n}\n"
            ],
            "language": [
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2
            ]
        },
        "instruction": "Print one integer — the minimum length of the text after at most one abbreviation.",
        "generate_testcase": "\nimport traceback\nfrom string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\ndef generate_testcase(json_obj: dict) -> tuple[str, dict]:\n    \"\"\"\\n    Generate a test case for the \"abbreviation\" problem.\\n\\n    Parameters\\n    ----------\\n    json_obj : dict\\n        Must contain at least the key ``'n'`` – the number of words (1 ≤ n ≤ 300).\\n\\n    Returns\\n    -------\\n    tuple[str, dict]\\n        * The first element is a string in the input format:\\n          ``n`` on the first line and the space‑separated words on the second line.\\n        * The second element is a dictionary describing the same test case:\\n          ``{'n': n, 'words': [w1, w2, ..., wn]}``.\\n    \"\"\"\n    import random\n    import string\n\n    # Extract the required size.\n    n = json_obj.get(\"n\", 1)\n    if not (1 <= n <= 300):\n        raise ValueError(\"n must be between 1 and 300 inclusive.\")\n\n    # Helper to produce a random lowercase word of length 1‑10.\n    def random_word(min_len: int = 1, max_len: int = 10) -> str:\n        length = random.randint(min_len, max_len)\n        return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\n    # Decide on a repeated pattern to guarantee an abbreviation opportunity.\n    # For n < 2 we cannot have a repeated segment; just generate random words.\n    if n >= 2:\n        # Choose pattern length L >= 1, ensuring we can place two copies.\n        max_L = n // 2\n        # Prefer L >= 2 when possible to guarantee a positive length reduction.\n        if max_L >= 2:\n            L = random.randint(2, max_L)\n        else:\n            L = 1  # n is 2 or 3 -> L must be 1.\n        # Create the pattern.\n        pattern = [random_word() for _ in range(L)]\n\n        # Choose a start position for the first occurrence.\n        # The second copy will be placed exactly L positions later,\n        # guaranteeing non‑overlap.\n        pos1 = random.randint(0, n - 2 * L)\n        pos2 = pos1 + L\n\n        # Initialise the list with placeholders.\n        words = [None] * n\n\n        # Insert the two copies of the pattern.\n        words[pos1:pos1 + L] = pattern\n        words[pos2:pos2 + L] = pattern\n\n        # Fill the remaining slots with random words.\n        for i in range(n):\n            if words[i] is None:\n                words[i] = random_word()\n    else:\n        # n == 1 – just a single random word.\n        words = [random_word()]\n\n    # Build the string representation.\n    input_str = f\"{n}\\n{' '.join(words)}\"\n\n    # Build the dictionary representation.\n    output_dict = {\"n\": n, \"words\": words}\n\n    return input_str, output_dict\n",
        "scale_range": 299,
        "output_type": "number",
        "is_output_unique": true,
        "difficulty_dict": {
            "0": 0,
            "1": 1,
            "2": 2,
            "3": 2,
            "4": 3,
            "5": 4,
            "6": 5,
            "7": 6,
            "8": 8,
            "9": 11,
            "10": 14,
            "11": 18,
            "12": 23,
            "13": 30,
            "14": 39,
            "15": 51,
            "16": 67,
            "17": 87,
            "18": 112,
            "19": 146,
            "20": 190,
            "21": 247,
            "22": 299
        },
        "params": {
            "n": {
                "min": 1,
                "max": 300,
                "base": 1.0
            },
            "difficulty": {
                "version": 1,
                "params": {
                    "dmax": 22,
                    "ema_beta": 0.0,
                    "activate_function": "base",
                    "history_len": 20,
                    "slope_scale": 0.05,
                    "age_scale": 100,
                    "alpha": 1.0,
                    "beta": 0.1
                }
            }
        }
    },
    "285_C. Building Permutation": {
        "name": "285_C. Building Permutation",
        "logic_description": "Permutation p is an ordered set of integers p1, p2, ..., pn, consisting of n distinct positive integers, each of them doesn't exceed n. We'll denote the i-th element of permutation p as pi. We'll call number n the size or the length of permutation p1, p2, ..., pn.\n\nYou have a sequence of integers a1, a2, ..., an. In one move, you are allowed to decrease or increase any number by one. Count the minimum number of moves, needed to build a permutation from this sequence.",
        "raw_description": "Permutation p is an ordered set of integers p1, p2, ..., pn, consisting of n distinct positive integers, each of them doesn't exceed n. We'll denote the i-th element of permutation p as pi. We'll call number n the size or the length of permutation p1, p2, ..., pn.\n\nYou have a sequence of integers a1, a2, ..., an. In one move, you are allowed to decrease or increase any number by one. Count the minimum number of moves, needed to build a permutation from this sequence.\n\nInput\n\nThe first line contains integer n (1 ≤ n ≤ 3·105) — the size of the sought permutation. The second line contains n integers a1, a2, ..., an ( - 109 ≤ ai ≤ 109).\n\nOutput\n\nPrint a single number — the minimum number of moves.\n\nPlease, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nExamples\n\nInput\n\n2\n3 0\n\n\nOutput\n\n2\n\n\nInput\n\n3\n-1 -1 2\n\n\nOutput\n\n6\n\nNote\n\nIn the first sample you should decrease the first number by one and then increase the second number by one. The resulting permutation is (2, 1).\n\nIn the second sample you need 6 moves to build permutation (1, 3, 2).",
        "solutions": {
            "solution": [
                "n = int(input())\nnums = sorted(list(map(int, input().split())))\nscore = 0\nfor i in range(n):\n    score+=abs(nums[i]-i-1)\nprint(score)\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  long long ar[300001];\n  for (int i = 0; i < n; i++) {\n    cin >> ar[i];\n  }\n  sort(ar, ar + n);\n  long long dp[300001];\n  int was = 1;\n  dp[0] = 0;\n  for (int i = 1; i <= n; i++) {\n    dp[i] = dp[i - 1] + abs(i - ar[i - 1]);\n    was++;\n  }\n  cout << dp[n];\n  return 0;\n}\n",
                "\nn = int(input())\nvalues = [int(x) for x in input().split(' ')]\n\n\nvalues.sort()\n\nresult = 0\nfor i, x in enumerate(values):\n    result += abs(x - (i + 1))\n\nprint(result)\n\n\n",
                "n = int(input())\nl = [int(i) for i in input().split()]\nl.sort()\nt = 0\nfor i in range(1,n+1):\n\tt+=abs(l[i-1]-i)\nprint(t)\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nlong long int power(long long int x, long long int y, long long int p) {\n  long long int r = 1;\n  x = x % p;\n  while (y) {\n    if (y & 1) r = r * x % p;\n    y = y >> 1;\n    x = x * x % p;\n  }\n  return r;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int n;\n  cin >> n;\n  int a[n];\n  for (int i = 0; i < n; i++) cin >> a[i];\n  sort(a, a + n);\n  long long int ct = 0;\n  for (int i = 0; i < n; i++) {\n    ct += abs(a[i] - (i + 1));\n  }\n  cout << ct << endl;\n}\n",
                "n=int(input())\nli=list(map(int,input().split()))\nli.sort()\nans=0\nfor i in range(n):\n    ans+=abs(i+1-li[i])\nprint(ans)\n",
                "n=int(input())\nl=list(map(int,input().split()))\nl.sort()\nk=0\nfor i in range(n):\n    k+=abs(l[i]-(i+1))\nprint(k)    \n    ",
                "#include <bits/stdc++.h>\nusing namespace std;\nvoid printv(vector<long long int> v) {\n  long long int sz = v.size();\n  for (long long int i = 0; i < sz; i++) {\n    if (i == sz - 1)\n      cout << v[i] << \"\\n\";\n    else\n      cout << v[i] << \" \";\n  }\n}\nvoid input(long long int a[], long long int sz) {\n  for (long long int i = 0; i < sz; i++) cin >> a[i];\n}\nvoid print(long long int a[], long long int sz) {\n  for (long long int i = 0; i < sz; i++) {\n    if (i == sz - 1)\n      cout << a[i] << \"\\n\";\n    else\n      cout << a[i] << \" \";\n  }\n}\nlong long int dx1[] = {1, 1, 0, -1, -1, -1, 0, 1};\nlong long int dy1[] = {0, 1, 1, 1, 0, -1, -1, -1};\nlong long int dx2[] = {1, 0, -1, 0};\nlong long int dy2[] = {0, 1, 0, -1};\nlong long int mul(long long int a, long long int b,\n                  long long int p = 1000000007) {\n  return ((a % p) * (b % p)) % p;\n}\nlong long int add(long long int a, long long int b,\n                  long long int p = 1000000007) {\n  return (a % p + b % p) % p;\n}\nlong long int power(long long int x, long long int y,\n                    long long int p = 1000000007) {\n  long long int res = 1;\n  x = x % p;\n  while (y > 0) {\n    if (y & 1) res = (res * x) % p;\n    y = y >> 1;\n    x = (x * x) % p;\n  }\n  return res;\n}\nlong long int modInverse(long long int n, long long int p = 1000000007) {\n  return power(n, p - 2, p);\n}\nlong long int ncrMod(long long int n, long long int r,\n                     long long int p = 1000000007) {\n  if (r == 0) return 1;\n  long long int fac[n + 1];\n  fac[0] = 1;\n  for (long long int i = 1; i <= n; i++) fac[i] = fac[i - 1] * i % p;\n  return (fac[n] * modInverse(fac[r], p) % p * modInverse(fac[n - r], p) % p) %\n         p;\n}\nbool isPrime(long long int n) {\n  for (int i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\nbool cmp(pair<long long int, long long int>& a,\n         pair<long long int, long long int>& b) {\n  if (a.first == b.first) {\n    return (a.second < b.second);\n  } else {\n    return (a.first > b.first);\n  }\n}\nvoid solve() {\n  long long int n;\n  cin >> n;\n  long long int a[n];\n  input(a, n);\n  sort(a, a + n);\n  long long int cnt = 0;\n  for (int i = 0; i < n; i++) {\n    if (i + 1 > a[i]) {\n      cnt += (i + 1 - a[i]);\n    } else {\n      cnt += a[i] - (i + 1);\n    }\n  }\n  cout << cnt << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long int t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n",
                "N=int(input())\n\n\nA=list(map(int,input().split()))\nans=0\nA.sort()\nfor i in range(N):\n    ans+=abs(A[i]-(i+1))\nprint(ans)\n    \n",
                "input()\nxs = [int(x) for x in input().split()]\n\nxs.sort()\nsol = 0\n\nfor i in range(0, len(xs)):\n    sol += abs(xs[i] - (i + 1))\n\nprint (sol)\n"
            ],
            "language": [
                3,
                2,
                3,
                3,
                2,
                3,
                3,
                2,
                3,
                3
            ]
        },
        "instruction": "Print a single number — the minimum number of moves.\n\nPlease, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.",
        "generate_testcase": "\nimport traceback\nfrom string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nimport random\nfrom typing import Tuple, Dict, List\n\ndef generate_testcase(json_obj: dict) -> Tuple[str, dict]:\n    \"\"\"\\n    Generate a test case for the \"minimum moves to permutation\" problem.\\n\\n    Parameters\\n    ----------\\n    json_obj : dict\\n        Must contain a key ``\"n\"`` specifying the size of the permutation\\n        (1 ≤ n ≤ 3·10⁵).\\n\\n    Returns\\n    -------\\n    tuple[str, dict]\\n        * str – the input formatted as required by the problem:\\n          the first line is ``n``, the second line contains ``n`` space‑separated\\n          integers ``a₁ … aₙ``.\\n        * dict – a structured representation of the same test case:\\n          ``{\"n\": n, \"a\": [a₁, …, aₙ]}``.\\n    \"\"\"\n    # Extract the problem size\n    n: int = int(json_obj[\"n\"])\n    if n < 1:\n        raise ValueError(\"n must be at least 1\")\n\n    # Generate the array a_i.\n    # According to the instructions we keep generated values strictly smaller than 10000.\n    # The original problem allows values up to 1e9, but for test generation we stay in [-9999, 9999].\n    a: List[int] = [random.randint(-9999, 9999) for _ in range(n)]\n\n    # Build the textual input format.\n    input_str: str = f\"{n}\\n\" + \" \".join(map(str, a)) + \"\\n\"\n\n    # Build the dictionary representation.\n    output_dict: dict = {\"n\": n, \"a\": a}\n\n    return input_str, output_dict\n",
        "scale_range": 380,
        "output_type": "number",
        "is_output_unique": true,
        "difficulty_dict": {
            "0": 0,
            "1": 1,
            "2": 2,
            "3": 2,
            "4": 3,
            "5": 4,
            "6": 5,
            "7": 6,
            "8": 8,
            "9": 11,
            "10": 14,
            "11": 18,
            "12": 23,
            "13": 30,
            "14": 39,
            "15": 51,
            "16": 67,
            "17": 87,
            "18": 112,
            "19": 146,
            "20": 190,
            "21": 247,
            "22": 321,
            "23": 380
        },
        "params": {
            "n": {
                "min": 1,
                "max": 381,
                "base": 1.0
            },
            "difficulty": {
                "version": 1,
                "params": {
                    "dmax": 23,
                    "ema_beta": 0.0,
                    "activate_function": "base",
                    "history_len": 20,
                    "slope_scale": 0.05,
                    "age_scale": 100,
                    "alpha": 1.0,
                    "beta": 0.1
                }
            }
        }
    },
    "1200_A. Hotelier": {
        "name": "1200_A. Hotelier",
        "logic_description": "Amugae has a hotel consisting of 10 rooms. The rooms are numbered from 0 to 9 from left to right.\n\nThe hotel has two entrances — one from the left end, and another from the right end. When a customer arrives to the hotel through the left entrance, they are assigned to an empty room closest to the left entrance. Similarly, when a customer arrives at the hotel through the right entrance, they are assigned to an empty room closest to the right entrance.\n\nOne day, Amugae lost the room assignment list. Thankfully Amugae's memory is perfect, and he remembers all of the customers: when a customer arrived, from which entrance, and when they left the hotel. Initially the hotel was empty. Write a program that recovers the room assignment list from Amugae's memory.",
        "raw_description": "Amugae has a hotel consisting of 10 rooms. The rooms are numbered from 0 to 9 from left to right.\n\nThe hotel has two entrances — one from the left end, and another from the right end. When a customer arrives to the hotel through the left entrance, they are assigned to an empty room closest to the left entrance. Similarly, when a customer arrives at the hotel through the right entrance, they are assigned to an empty room closest to the right entrance.\n\nOne day, Amugae lost the room assignment list. Thankfully Amugae's memory is perfect, and he remembers all of the customers: when a customer arrived, from which entrance, and when they left the hotel. Initially the hotel was empty. Write a program that recovers the room assignment list from Amugae's memory.\n\nInput\n\nThe first line consists of an integer n (1 ≤ n ≤ 10^5), the number of events in Amugae's memory.\n\nThe second line consists of a string of length n describing the events in chronological order. Each character represents: \n\n  * 'L': A customer arrives from the left entrance. \n  * 'R': A customer arrives from the right entrance. \n  * '0', '1', ..., '9': The customer in room x (0, 1, ..., 9 respectively) leaves. \n\n\n\nIt is guaranteed that there is at least one empty room when a customer arrives, and there is a customer in the room x when x (0, 1, ..., 9) is given. Also, all the rooms are initially empty.\n\nOutput\n\nIn the only line, output the hotel room's assignment status, from room 0 to room 9. Represent an empty room as '0', and an occupied room as '1', without spaces.\n\nExamples\n\nInput\n\n\n8\nLLRL1RL1\n\n\nOutput\n\n\n1010000011\n\nInput\n\n\n9\nL0L0LLRR9\n\n\nOutput\n\n\n1100000010\n\nNote\n\nIn the first example, hotel room's assignment status after each action is as follows. \n\n  * First of all, all rooms are empty. Assignment status is 0000000000. \n  * L: a customer arrives to the hotel through the left entrance. Assignment status is 1000000000. \n  * L: one more customer from the left entrance. Assignment status is 1100000000. \n  * R: one more customer from the right entrance. Assignment status is 1100000001. \n  * L: one more customer from the left entrance. Assignment status is 1110000001. \n  * 1: the customer in room 1 leaves. Assignment status is 1010000001. \n  * R: one more customer from the right entrance. Assignment status is 1010000011. \n  * L: one more customer from the left entrance. Assignment status is 1110000011. \n  * 1: the customer in room 1 leaves. Assignment status is 1010000011. \n\n\n\nSo after all, hotel room's final assignment status is 1010000011.\n\nIn the second example, hotel room's assignment status after each action is as follows. \n\n  * L: a customer arrives to the hotel through the left entrance. Assignment status is 1000000000. \n  * 0: the customer in room 0 leaves. Assignment status is 0000000000. \n  * L: a customer arrives to the hotel through the left entrance. Assignment status is 1000000000 again. \n  * 0: the customer in room 0 leaves. Assignment status is 0000000000. \n  * L: a customer arrives to the hotel through the left entrance. Assignment status is 1000000000. \n  * L: one more customer from the left entrance. Assignment status is 1100000000. \n  * R: one more customer from the right entrance. Assignment status is 1100000001. \n  * R: one more customer from the right entrance. Assignment status is 1100000011. \n  * 9: the customer in room 9 leaves. Assignment status is 1100000010. \n\n\n\nSo after all, hotel room's final assignment status is 1100000010.",
        "solutions": {
            "solution": [
                "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  long long int n;\n  cin >> n;\n  string s;\n  long long int b[10] = {0};\n  cin >> s;\n  for (long long int i = 0; i < n; i++) {\n    if (s[i] == 'L') {\n      for (long long int j = 0; j < 10; j++) {\n        if (b[j] == 0) {\n          b[j] = 1;\n          break;\n        }\n      }\n    } else if (s[i] == 'R') {\n      for (long long int j = 9; j >= 0; j--) {\n        if (b[j] == 0) {\n          b[j] = 1;\n          break;\n        }\n      }\n    } else {\n      int x = int(s[i] - '0');\n      b[x] = 0;\n    }\n  }\n  for (int i = 0; i < 10; i++) cout << b[i];\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nvoid arrayIn(long long* A, long long n) {\n  for (long long K = 0; K < n; K++) {\n    cin >> A[K];\n  }\n}\nvoid arrayOut(long long* A, long long n) {\n  for (long long K = 0; K < n; K++) {\n    cout << A[K] << ' ';\n  }\n}\nlong long n;\nstring second;\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  ;\n  cin >> n;\n  cin >> second;\n  long long ans[15];\n  memset(ans, 0, sizeof(ans));\n  for (int i = 0; i < n; ++i) {\n    if (second[i] == 'L') {\n      for (int j = 0; j < 10; ++j) {\n        if (ans[j] == 0) {\n          ans[j] = 1;\n          break;\n        }\n      }\n    } else if (second[i] == 'R') {\n      for (int j = 9; j >= 0; j--) {\n        if (ans[j] == 0) {\n          ans[j] = 1;\n          break;\n        }\n      }\n    } else {\n      ans[second[i] - '0'] = 0;\n    }\n  }\n  for (int i = 0; i < 10; ++i) {\n    cout << ans[i];\n  }\n  return 0;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nint st[10];\nint l, r, n;\nstring str;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  cin >> str;\n  l = 0;\n  r = 9;\n  for (int i = 0; i < n; i++) {\n    if (str[i] == 'L') {\n      l = 0;\n      while (st[l]) l++;\n      st[l] = 1;\n    } else if (str[i] == 'R') {\n      r = 9;\n      while (st[r]) r--;\n      st[r] = 1;\n    } else\n      st[str[i] - '0'] = 0;\n  }\n  for (int i = 0; i < 10; i++) cout << st[i];\n  cout << endl;\n  return 0;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int a[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n  int n, l = 0, r = 9;\n  cin >> n;\n  char str[n];\n  cin >> str;\n  for (int i = 0; i < strlen(str); i++) {\n    if (str[i] == 'L') {\n      for (int j = 0; j < 10; j++) {\n        if (a[j] == 0) {\n          a[j] = 1;\n          break;\n        }\n      }\n    } else if (str[i] == 'R') {\n      for (int j = 9; j >= 0; j--) {\n        if (a[j] == 0) {\n          a[j] = 1;\n          break;\n        }\n      }\n    } else {\n      int x = str[i] - 48;\n      a[x] = 0;\n    }\n  }\n  for (int i = 0; i < 10; i++) cout << a[i];\n  return 0;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nchar str[100010];\nint a[10] = {0};\nint main() {\n  scanf(\"%d\", &n);\n  scanf(\"%s\", str);\n  for (int i = 0; i < n; i++) {\n    if (str[i] == 'L') {\n      for (int j = 0; j <= 9; j++) {\n        if (a[j] == 0) {\n          a[j] = 1;\n          break;\n        }\n      }\n    } else if (str[i] == 'R') {\n      for (int j = 9; j >= 0; j--) {\n        if (a[j] == 0) {\n          a[j] = 1;\n          break;\n        }\n      }\n    } else {\n      a[str[i] - '0'] = 0;\n    }\n  }\n  for (int i = 0; i <= 9; i++) printf(\"%d\", a[i]);\n  printf(\"\\n\");\n  return 0;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nlong long mcm(long long a, long long b) { return (a * b) / gcd(a, b); }\nvoid solve() {\n  int n;\n  cin >> n;\n  string second;\n  vector<int> ans(10, 0);\n  cin >> second;\n  for (int i = 0; i < n; i++) {\n    if (second[i] == 'L') {\n      for (int j = 0; j < n; j++) {\n        if (ans[j] == 0) {\n          ans[j] = 1;\n          break;\n        }\n      }\n    } else if (second[i] == 'R') {\n      for (int j = 9; j >= 0; j--) {\n        if (ans[j] == 0) {\n          ans[j] = 1;\n          break;\n        }\n      }\n    } else {\n      ans[(int)second[i] - '0'] = 0;\n    }\n  }\n  for (auto &x : ans) cout << x;\n  cout << endl;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  while (t-- > 0) solve();\n  return 0;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> v;\nvoid leftInsert(int pos) {\n  if (v[pos] == 1) {\n    leftInsert(pos + 1);\n  } else\n    v[pos] = 1;\n}\nvoid rightInsert(int pos) {\n  if (v[pos] == 1) {\n    rightInsert(pos - 1);\n  } else\n    v[pos] = 1;\n}\nint main() {\n  int n;\n  cin >> n;\n  v.resize(10);\n  for (int i = 0; i < 10; i++) v[i] = 0;\n  string input;\n  cin >> input;\n  for (int i = 0; i < input.length(); i++) {\n    if (input.at(i) == 'L') {\n      leftInsert(0);\n    } else if (input.at(i) == 'R') {\n      rightInsert(9);\n    } else {\n      string s(1, input.at(i));\n      int ind = stoi(s);\n      v[ind] = 0;\n    }\n  }\n  for (int i = 0; i < 10; i++) {\n    cout << v[i];\n  }\n  return 0;\n}\n",
                "#include <bits/stdc++.h>\nint main() {\n  int t[10], i, j, p, n;\n  scanf(\"%d\", &n);\n  char s[100001];\n  for (j = 0; j <= n; j++) scanf(\"%c\", &s[j]);\n  for (i = 0; i < 10; i++) t[i] = 0;\n  for (j = 0; j <= n; j++) {\n    if (s[j] == 'L') {\n      i = 0;\n      while (t[i] != 0 && i < 10) i++;\n      t[i] = 1;\n    }\n    if (s[j] == 'R') {\n      i = 0;\n      while (t[9 - i] != 0 && i < 10) i++;\n      t[9 - i] = 1;\n    } else {\n      p = s[j] - 48;\n      t[p] = 0;\n    }\n  }\n  for (i = 0; i < 10; i++) printf(\"%d\", t[i]);\n  return 0;\n}\n",
                "input()\nl = [0]*10\ns = input()\nfor i in range(len(s)):\n    e = s[i]\n    if e == 'L':\n        l[l.index(0)] = 1\n    elif e == 'R':\n        l[len(l) - l[::-1].index(0) - 1] = 1\n    else:\n        l[int(e)] = 0\nprint(*l, sep = '')\n    ",
                "\n\n# target Expert  \n\n# Certainly a bad contest for me... lets's move on and focus on nxt :)\n\n\n# Author : raj1307 - Raj Singh\n# Date   : 12.08.19\n\nfrom __future__ import division, print_function\n\nimport os,sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef ii(): return int(input())\ndef si(): return input()\ndef mi(): return map(int,input().strip().split(\" \"))\ndef li(): return list(mi())\n\ndef dmain():\n    sys.setrecursionlimit(100000000)\n    threading.stack_size(40960000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \n#from collections import deque, Counter, OrderedDict,defaultdict\n#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n#from math import ceil,floor,log,sqrt,factorial,pi,log2\n#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n#from decimal import *,threading\n#from itertools import permutations\n\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod=1000000007\n#mod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\ndef getKey(item): return item[0] \ndef sort2(l):return sorted(l, key=getKey)\ndef d2(n,m,num):return [[num for x in range(m)] for y in range(n)]\ndef isPowerOfTwo (x): return (x and (not(x & (x - 1))) )\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\ndef ntl(n):return [int(i) for i in str(n)]\n\ndef powerMod(x,y,p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y&1:\n            res = (res*x)%p\n        y = y>>1\n        x = (x*x)%p\n    return res\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef isPrime(n) : # Check Prime Number or not \n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\n\n\n\ndef read():\n    sys.stdin = open('input.txt', 'r')  \n    sys.stdout = open('output.txt', 'w') \n\n\n\n\ndef main():\n\n    \n\n    #for _ in range(ii()):\n        \n    \n    n=ii()\n    s=si()\n\n    l=[0]*10\n\n    for i in range(n):\n        if s[i]=='L':\n            for i in range(n):\n                if l[i]==0:\n                    l[i]=1\n                    break\n\n        elif s[i]=='R':\n            for i in range(9,-1,-1):\n                if l[i]==0:\n                    l[i]=1\n                    break\n\n        else:\n            l[int(s[i])]=0\n\n\n\n    for i in range(10):\n        print(l[i],end='')\n\n\n\n    \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\nif __name__ == \"__main__\":\n    #read()\n    main()\n    #dmain()\n\n# Comment Read()\n"
            ],
            "language": [
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                3,
                3
            ]
        },
        "instruction": "In the only line, output the hotel room's assignment status, from room 0 to room 9. Represent an empty room as '0', and an occupied room as '1', without spaces.",
        "generate_testcase": "\nimport traceback\nfrom string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nimport random\n\ndef generate_testcase(json_obj: dict) -> tuple[str, dict]:\n    \"\"\"\\n    Generate a test case for the hotel room assignment problem.\\n\\n    Parameters\\n    ----------\\n    json_obj : dict\\n        Must contain a numeric field ``n`` – the number of events to generate.\\n        Optionally, a ``seed`` field can be provided to make the generation\\n        deterministic.\\n\\n    Returns\\n    -------\\n    tuple[str, dict]\\n        The first element is the raw input string (including the leading ``n``).\\n        The second element is a structured dictionary with the same data.\\n    \"\"\"\n    # --------------------------------------------------------------------\n    # Extract and validate the scale parameter.\n    # --------------------------------------------------------------------\n    n = json_obj.get(\"n\")\n    if n is None:\n        raise ValueError(\"json_obj must contain the key 'n'\")\n    n = int(n)\n    # The problem limits n to 1 ≤ n ≤ 10⁵.\n    n = max(1, min(n, 100_000))\n\n    # Optional deterministic seed.\n    seed = json_obj.get(\"seed\")\n    if seed is not None:\n        random.seed(int(seed))\n\n    # --------------------------------------------------------------------\n    # Simulate the hotel occupancy while generating a random valid sequence.\n    # --------------------------------------------------------------------\n    occupied = [False] * 10                # current status of rooms 0‑9\n    events: list[str] = []                # the event characters\n\n    for _ in range(n):\n        # Determine which actions are currently legal.\n        empty_rooms = [i for i, v in enumerate(occupied) if not v]\n        occupied_rooms = [i for i, v in enumerate(occupied) if v]\n\n        possible_actions: list[str] = []\n        if empty_rooms:                    # arrivals are possible\n            possible_actions.append('L')\n            possible_actions.append('R')\n        if occupied_rooms:                 # departures are possible\n            possible_actions.extend(str(d) for d in occupied_rooms)\n\n        # Choose uniformly among the feasible actions.\n        act = random.choice(possible_actions)\n\n        if act == 'L':\n            # Assign to the leftmost empty room.\n            idx = min(empty_rooms)\n            occupied[idx] = True\n            events.append('L')\n        elif act == 'R':\n            # Assign to the rightmost empty room.\n            idx = max(empty_rooms)\n            occupied[idx] = True\n            events.append('R')\n        else:\n            # Departure from the specified room.\n            idx = int(act)\n            occupied[idx] = False\n            events.append(act)\n\n    event_str = ''.join(events)\n    input_str = f\"{n}\\n{event_str}\"\n    output_dict = {\"n\": n, \"events\": event_str}\n    return input_str, output_dict\n",
        "scale_range": 2042,
        "output_type": "string",
        "is_output_unique": true,
        "difficulty_dict": {
            "0": 0,
            "1": 2,
            "2": 3,
            "3": 4,
            "4": 7,
            "5": 10,
            "6": 17,
            "7": 27,
            "8": 43,
            "9": 69,
            "10": 110,
            "11": 176,
            "12": 281,
            "13": 450,
            "14": 721,
            "15": 1153,
            "16": 1845,
            "17": 2042
        },
        "params": {
            "n": {
                "min": 1,
                "max": 2043,
                "base": 1.0
            },
            "difficulty": {
                "version": 1,
                "params": {
                    "dmax": 17,
                    "ema_beta": 0.0,
                    "activate_function": "base",
                    "history_len": 20,
                    "slope_scale": 0.05,
                    "age_scale": 100,
                    "alpha": 1.0,
                    "beta": 0.1
                }
            }
        }
    },
    "p02158 Rings": {
        "name": "p02158 Rings",
        "logic_description": "Problem\n\nA dolphin who lives in a certain aquarium will be rewarded if he jumps and goes through the $ N $ ring.\n\n* Dolphin jumps from coordinates $ (0,0) $ and lands at $ (T,0) $.\n* The trajectory of the jump is a parabola.\n* The $ i $ th ring is determined to have passed through when the jump trajectory intersects the line segment connecting $ (X_i, L_i) $ and $ (X_i, H_i) $.\n* $ 1 $ jump requires as much physical strength as the initial velocity.\n\n\n\nDolphins can jump as many times as they want. Let the gravitational acceleration vector be $ (0, -1) $ and find the minimum total physical strength required for the dolphin to pass through all the rings. However, suppose friction and air resistance are negligibly small.\n\nConstraints\n\nThe input satisfies the following conditions.\n\n* All inputs are integers.\n* $ 1 \\ le X_i <T \\ le 10 ^ 6 $\n* $ 1 \\ le N \\ le 10 ^ 5 $\n* $ 1 \\ le L_i <H_i \\ le 10 ^ 6 $",
        "raw_description": "Problem\n\nA dolphin who lives in a certain aquarium will be rewarded if he jumps and goes through the $ N $ ring.\n\n* Dolphin jumps from coordinates $ (0,0) $ and lands at $ (T,0) $.\n* The trajectory of the jump is a parabola.\n* The $ i $ th ring is determined to have passed through when the jump trajectory intersects the line segment connecting $ (X_i, L_i) $ and $ (X_i, H_i) $.\n* $ 1 $ jump requires as much physical strength as the initial velocity.\n\n\n\nDolphins can jump as many times as they want. Let the gravitational acceleration vector be $ (0, -1) $ and find the minimum total physical strength required for the dolphin to pass through all the rings. However, suppose friction and air resistance are negligibly small.\n\nConstraints\n\nThe input satisfies the following conditions.\n\n* All inputs are integers.\n* $ 1 \\ le X_i <T \\ le 10 ^ 6 $\n* $ 1 \\ le N \\ le 10 ^ 5 $\n* $ 1 \\ le L_i <H_i \\ le 10 ^ 6 $\n\nInput\n\nThe input is given in the following format.\n\n\n$ T $ $ N $\n$ X_1 $ $ L_1 $ $ H_1 $\n$ \\ vdots $\n$ X_N $ $ L_N $ $ H_N $\n\n\nFirst, $ T $ and $ N $ are given to the $ 1 $ line. Then the $ N $ line is given the position of the $ i $ th ring, $ X_i $, $ L_i $, and $ H_i $.\n\nOutput\n\nOutput the answer on one line. If the absolute error or relative error is $ 10 ^ {-9} $ or less, the answer is judged to be correct.\n\nExamples\n\nInput\n\n100 5\n50 1 5\n50 5 10\n50 20 30\n50 40 60\n50 61 1000000\n\n\nOutput\n\n48.6090201099\n\n\nInput\n\n64 15\n38 133177 927361\n48 177920 668766\n12 680425 790550\n43 6853 384115\n17 214954 723798\n62 63843 153825\n28 399349 482937\n2 336136 367001\n33 138008 733496\n6 203462 911631\n58 321974 527734\n17 696940 781678\n55 265874 507640\n41 56037 880001\n34 279422 528651\n\n\nOutput\n\n6087.909851326286",
        "solutions": {
            "solution": [
                "#include<bits/stdc++.h>\nusing namespace std;\n\nclass fraction {\n    long long numer; // bunshi\n    long long denom; // bunbo\npublic:\n    fraction(long long numer, long long denom) : numer(numer), denom(denom) {}\n    int compare_to(const fraction& f) const {\n        assert(denom > 0 && f.denom > 0);\n        long long res = numer * f.denom - denom * f.numer;\n        if (res > 0) return 1;\n        else if (res < 0) return -1;\n        else return 0;\n    }\n    long double to_float() const {\n        return numer / (long double)denom;\n    }\n};\n\nusing P = pair<fraction, fraction>;\n\n\nint main() {\n    long long t;\n    int n;\n    cin >> t >> n;\n    vector<P> upper, lower, middle;\n    for (int i = 0; i < n; ++i) {\n        long long x, a, b;\n        cin >> x >> a >> b;\n        fraction ta(a, x * (t - x));\n        fraction tb(b, x * (t - x));\n        if (a * t > x * (t - x)) upper.push_back({ta, tb});\n        else if (b * t < x * (t - x)) lower.push_back({ta, tb});\n        else middle.push_back({ta, tb});\n    }\n    sort(upper.begin(), upper.end(), [](const P& a, const P& b) { return a.first.compare_to(b.first) > 0; });\n    sort(lower.begin(), lower.end(), [](const P& a, const P& b) { return a.second.compare_to(b.second) < 0; });\n\n    long double ans = 0;\n    fraction last1(1e6 + 10, 1), last2(-(1e6 + 10), 1);\n    for (auto& i : upper) {\n        if (last1.compare_to(i.second) > 0) {\n            ans += sqrt(i.first.to_float() * t * t / 2 + 1 / (i.first.to_float() * 2));\n            last1 = i.first;\n        }\n    }\n    for (auto& i : lower) {\n        if (last2.compare_to(i.first) < 0) {\n            ans += sqrt(i.second.to_float() * t * t / 2 + 1 / (i.second.to_float() * 2));\n            last2 = i.second;\n        }\n    }\n    bool ad = false;\n    for (auto& i : middle) {\n        if ((i.second.compare_to(last1) < 0 || i.first.compare_to(last1) > 0) && (i.second.compare_to(last2) < 0 || i.first.compare_to(last2) > 0)) {\n            ad = true;\n            break;\n        }\n    }\n    if (ad) ans += sqrt(t);\n    cout << setprecision(24) << ans << '\\n';\n    return 0;\n}\n\n",
                "// vvvvvvvvvvvv TEMPLATE vvvvvvvvvvvv\n#include <bits/stdc++.h>\n#define double long double\nusing namespace std; using ll = long long; using P = pair<ll, ll>;\nconst ll linf = 1e18; const double eps = 1e-20, pi = acos(-1);\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define each(i,a) for (auto&& i : a)\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define eb emplace_back\n#define all(a) begin(a),end(a)\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n#define min(x,y) (x < y ? x : y)\n#define max(x,y) (x < y ? y : x)\ntemplate<typename Head> void out(Head h) { cout << h << endl; } template<typename Head, typename... Tail>void out(Head h, Tail... t) { cout << h << \" \"; out(t...); }\ntemplate<typename T> istream& operator>>(istream& is, vector<T>& v) { each(x,v) is >> x; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) { rep(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<string>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<vector<T>>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\nstruct yes_no : std::numpunct<char> { string_type do_truename() const { return \"Yes\"; } string_type do_falsename() const { return \"No\"; } };\nvoid solve(); int main() {\n  ios::sync_with_stdio(false); cin.tie(0); locale loc(locale(), new yes_no); cout.imbue(loc); cout << fixed << setprecision(16) << boolalpha;\n  solve();\n}\n// ^^^^^^^^^^^^ TEMPLATE ^^^^^^^^^^^^\n\nusing PD = pair<double, double>;\n\nll T;\n\ndouble get_v0(double y) {\n  double W = T/2., H = y;\n  double vx = W / sqrt(2 * H);\n  double vy = sqrt(2 * H);\n  return sqrt(vx * vx + vy * vy);\n}\n\ndouble f(double x, double y) {\n  double a = x, b = y, W = T/2.;\n  return b * W * W / (2 * a * W - a * a);\n}\n\nPD solve1(vector<PD> v) {\n  each(p, v) swap(p.first, p.second);\n  sort(all(v));\n  double res = 0;\n  double r = -linf;\n  ll cnt = 0;\n  each(p, v) {\n    if (r >= p.second-eps) continue;\n    r = p.first;\n    res += get_v0(p.first);\n    ++cnt;\n  }\n  // cout << cnt << endl;\n  return PD(res, r);\n}\nPD solve2(vector<PD> v) {\n  sort(all(v), greater<PD>());\n  double res = 0;\n  double l = linf;\n  ll cnt = 0;\n  each(p, v) {\n    if (l <= p.second-eps) continue;\n    l = p.first;\n    res += get_v0(p.first);\n    ++cnt;\n  }\n  // cout << cnt << endl;\n  return PD(res, l);\n}\n\nvoid solve() {\n  ll n; cin >> T >> n;\n  vector<ll> X(n), L(n), H(n);\n  rep(i, n) cin >> X[i] >> L[i] >> H[i];\n  vector<PD> left, right, middle;\n  double v = sqrt(T/2.);\n  double tmid = T / v;\n  double th = T / 4.;\n  rep(i, n) {\n    double l = f(X[i], L[i]);\n    double r = f(X[i], H[i]);\n    if (r <= th+eps) {\n      left.eb(l, r);\n    }\n    else if (l >= th-eps) {\n      right.eb(l, r);\n    }\n    else {\n      middle.eb(l, r);\n    }\n    // cout << X[i] << \" \" << L[i] << \" \" << l << \" \" << r << endl;\n  }\n  // cout << left.size() << \" \" << right.size() << endl;\n  auto r1 = solve1(left);\n  auto r2 = solve2(right);\n  // cout << r1.first << \" \" << get_v0(0.1973955598) << endl;\n  double ans = r1.first + r2.first;\n  double l = r1.second;\n  double r = r2.second;\n  bool flag = false;\n  each(p, middle) {\n    if (l+eps < p.first && p.second < r-eps) {\n      flag = true;\n      break;\n    }\n  }\n  // 45度とばす\n  if (flag) {\n    ans += get_v0(th);\n  }\n  cout << ans << endl;\n}\n\n",
                "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    long T, N;\n    cin >> T >> N;\n    vector<pair<long double, long double>> tapi, tapu, tape;\n    {\n        long x, l, h;\n        auto alpha = static_cast<long double>(1) / T;\n        for (int i = 0; i < N; ++i) {\n            cin >> x >> l >> h;\n            auto a = l / static_cast<long double>((T - x) * x), b = h / static_cast<long double>((T - x) * x);\n            if(alpha < a)tape.emplace_back(a, b);\n            if(a <= alpha && alpha <= b)tapi.emplace_back(a, b);\n            if(alpha > b)tapu.emplace_back(b, a);\n        }\n        sort(tapu.begin(), tapu.end());\n        sort(tapi.begin(), tapi.end());\n        sort(tape.rbegin(), tape.rend());\n    }\n\n    vector<long double> hoge;\n    long double now1 = -1000000000000;\n    for(auto i : tapu){\n        if(i.first < now1 || i.second > now1){\n            hoge.push_back(i.first);\n            now1 = i.first;\n        }\n    }\n    long double now2 = -1000000000000;\n    for(auto i : tape){\n        if(i.first > now2 || i.second < now2){\n            hoge.push_back(i.first);\n            now2 = i.first;\n        }\n    }\n    for(auto i : tapi){\n        if(!((i.first <= now1 && now1 <= i.second) || (i.first <= now2 && now2 <= i.second))){\n            hoge.push_back(static_cast<long double>(1) / T);\n            break;\n        }\n    }\n    auto S = [&T](long double k){\n        return sqrt(1 / (2 * k) + (T * T * k) / 2);\n    };\n    long double ans = 0;\n    for(auto i : hoge)ans += S(i);\n    printf(\"%.12Lf\\n\", ans);\n    return 0;\n}\n",
                "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\n// chmax, chmin\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n// debug stream of pair, vector \n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\n\n\n// 有理数\nlong long calc_gcd(long long a, long long b) {return b ? calc_gcd(b, a % b) : a;}\nstruct frac {\n    long long first, second;\n\n    using D = long double;\n    inline frac normalize() {\n        if (second < 0) {first = -first; second = -second;}\n        long long d = calc_gcd(abs(first), abs(second));\n        if (d == 0) {first = 0; second = 1;}\n        else {first /= d; second /= d;}\n        return *this;\n    }\n    frac(long long f = 0, long long s = 1) : first(f), second(s) { normalize(); }\n    inline D to_d() const { return D(first) / second; }\n    inline frac operator - () { (*this).first *= -1; return (*this); }\n    inline const frac& operator = (long long a) { *this = frac(a, 1); return *this; }\n    inline const frac& operator += (const frac& a);\n    inline const frac& operator += (long long a);\n    inline const frac& operator -= (const frac& a);\n    inline const frac& operator -= (long long a);\n    inline const frac& operator *= (const frac& a);\n    inline const frac& operator *= (long long a);\n    inline const frac& operator /= (const frac& a);\n    inline const frac& operator /= (long long a);\n    inline friend ostream& operator << (ostream& s, const frac& f) { \n        s << f.first; if (f.second != 1) s << \"/\" << f.second; return s;\n    }\n};\ninline bool operator == (const frac &a, const frac&b) {\n    return a.first * b.second == a.second * b.first;\n}\ninline bool operator != (const frac &a, const frac &b) { return !(a == b); }\ninline bool operator < (const frac& a, const frac& b) {\n    return a.first * b.second < a.second * b.first;\n}\ninline bool operator > (const frac& a, const frac& b) { return b < a; }\ninline bool operator <= (const frac& a, const frac& b) {\n    return a.first * b.second <= a.second * b.first;\n}\ninline bool operator >= (const frac& a, const frac& b) { return b <= a; }\ninline frac operator + (const frac& a, const frac& b) {\n    frac res;\n    res.first = a.first * b.second + a.second * b.first;\n    res.second = a.second * b.second;\n    res.normalize();\n    return res;\n}\ninline frac operator - (const frac& a, const frac& b) {\n    frac res;\n    res.first = a.first * b.second - a.second * b.first;\n    res.second = a.second * b.second;\n    res.normalize();\n    return res;\n}\ninline frac operator * (const frac& a, const frac& b) {\n    frac res;\n    res.first = a.first * b.first;\n    res.second = a.second * b.second;\n    res.normalize();\n    return res;\n}\ninline frac operator / (const frac& a, const frac& b) {\n    frac res;\n    res.first = a.first * b.second;\n    res.second = a.second * b.first;\n    res.normalize();\n    return res;\n}\ninline frac abs(const frac& a) {\n    frac res; res = a; res.normalize(); \n    if (res.first < 0) res.first = res.first * (-1);\n    return res;\n}\ninline const frac& frac::operator += (const frac& x) {*this = *this + x; return *this;}\ninline const frac& frac::operator += (long long x) {*this = *this + x; return *this;}\ninline const frac& frac::operator -= (const frac& x) {*this = *this - x; return *this;}\ninline const frac& frac::operator -= (long long x) {*this = *this + x; return *this;}\ninline const frac& frac::operator *= (const frac& x) {*this = *this * x; return *this;}\ninline const frac& frac::operator *= (long long x) {*this = *this * x; return *this;}\ninline const frac& frac::operator /= (const frac& x) {*this = *this / x; return *this;}\ninline const frac& frac::operator /= (long long x) {*this = *this / x; return *this;}\n\n\n\nlong double cost(const frac &f, long long T) {\n    long double df = f.to_d();\n    return sqrt(df * T * T / 2 + 0.5 / df);\n}\n\nint main() {\n    long long T; int N;\n    cin >> T >> N;\n    const frac center(1, T); // 45 度打ち出しの場合\n    using pf = pair<frac,frac>;\n    vector<pf> upper, lower, middle;\n    for (int i = 0; i < N; ++i) {\n        long long x, low, up; cin >> x >> low >> up;\n        frac flow(low, x * (T-x));\n        frac fup(up, x * (T-x));\n        if (fup < center) lower.push_back({flow, fup});\n        else if (flow > center) upper.push_back({flow, fup});\n        else middle.push_back({flow, fup});\n    }\n    sort(lower.begin(), lower.end(), [](const pf &a, const pf &b) {\n            return a.second < b.second;});\n    sort(upper.begin(), upper.end(), [](const pf &a, const pf &b) {\n            return a.first > b.first;});\n\n    long double res = 0.0;\n    frac left = 0, right = 1000100; // right * 10^12/4 がオーバーフローしないように\n    for (auto inter : lower) {\n        if (left >= inter.first) continue;\n        res += cost(inter.second, T);\n        left = inter.second;\n    }\n    for (auto inter : upper) {\n        if (right <= inter.second) continue;\n        res += cost(inter.first, T);\n        right = inter.first;\n    }\n    bool remain = false;\n    for (auto inter : middle) {\n        if (left < inter.first && inter.second < right) remain = true;\n    }\n    if (remain) res += cost(center, T);\n    cout << fixed << setprecision(20) << res << endl;\n}\n\n",
                "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\n// chmax, chmin\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n// debug stream of pair, vector\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\n\n\n// 有理数\ntemplate<typename T> class Rational {\nprivate:\n    static Rational make(const T& x, const T& y){\n        Rational m; return m.num = x, m.den = y, m;\n    }\npublic:\n    friend ostream& operator<<(ostream& os, const Rational& rn) {\n        return (os << rn.num << \" / \" << rn.den);\n    }\n    Rational& operator=(T val){ return *this = Rational(val); }\n    bool operator<(const Rational& val) const { return num*val.den < den*val.num; }\n    bool operator<(const T val) const { return *this < Rational(val); }\n    friend bool operator<(const T val1, const Rational& val2){ return Rational(val1) < val2; }\n    bool operator>(const Rational& val) const { return val < *this; }\n    bool operator>(const T val) const { return *this > Rational(val); }\n    friend bool operator>(const T val1, const Rational& val2){ return Rational(val1) > val2; }\n    bool operator<=(const Rational& val) const { return !(*this > val); }\n    bool operator<=(const T val) const { return *this <= Rational(val); }\n    friend bool operator<=(const T val1, const Rational& val2){ return Rational(val1) <= val2; }\n    bool operator>=(const Rational& val) const { return !(*this < val); }\n    bool operator>=(const T val) const { return *this >= Rational(val); }\n    friend bool operator>=(const T val1, const Rational& val2){ return Rational(val1) >= val2; }\n    bool operator==(const Rational& val) const { return num*val.den == den*val.num; }\n    bool operator==(const T val) const { return *this == Rational(val); }\n    friend bool operator==(const T val1, const Rational& val2){ return Rational(val1) == val2; }\n    bool operator!=(const Rational& val) const { return !(*this == val); }\n    bool operator!=(const T val) const { return *this != Rational(val); }\n    friend bool operator!=(const T val1, const Rational& val2){ return Rational(val1) != val2; }\n    explicit operator bool() const noexcept { return num; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    Rational operator+() const { return *this; }\n    Rational operator-() const { return make(-num, den); }\n    friend Rational abs(const Rational& val){ return make(abs(val.num), val.den); }\n    Rational operator+(const Rational& val) const { return make(num*val.den+val.num*den, den*val.den); }\n    Rational operator+(T val) const { return *this + Rational(val); }\n    friend Rational operator+(T a, const Rational& b){ return b + a; }\n    Rational& operator+=(const Rational& val){ return *this = *this + val; }\n    Rational& operator+=(const T& val){ return *this = *this + val; }\n    Rational& operator++(){ return *this += 1; }\n    Rational operator++(int){ return make(num + den, den); }\n    Rational operator-(const Rational& val) const { return make(num*val.den-val.num*den, den*val.den); }\n    Rational operator-(T val) const { return *this - Rational(val); }\n    friend Rational operator-(T a, const Rational& b){ return Rational(a) - b; }\n    Rational& operator-=(const Rational& val){ return *this = *this - val; }\n    Rational& operator-=(const T& val){ return *this = *this - val; }\n    Rational& operator--(){ return *this -= 1; }\n    Rational operator--(int){ return make(num - den, den); }\n    Rational operator*(const Rational& val) const { return make(num*val.num, den*val.den); }\n    Rational operator*(T val) const { return *this * Rational(val); }\n    friend Rational operator*(T a, const Rational& b){ return b * a; }\n    Rational& operator*=(const Rational& val){ return *this = *this * val;}\n    Rational& operator*=(const T& val){ return *this = *this * val; }\n    Rational operator/(const Rational& val) const { return make(num*val.den, den*val.num); }\n    Rational operator/(T val) const { return *this / Rational(val); }\n    friend Rational operator/(T a, const Rational& b){ return Rational(a) / b; }\n    Rational& operator/=(const Rational& val){ return *this / val; }\n    Rational& operator/=(const T& val){ return *this = *this / val; }\n\n    T num, den;\n\n    Rational(){}\n    Rational(T num_) : num(num_), den(1){}\n    Rational(T num_, T den_) : num(num_), den(den_){ if(den < 0) num = -num, den = -den; }\n};\n\nlong double cost(const Rational<long long> &f, long long T) {\n    long double df = (long double)f.num/f.den;\n    return sqrt(df * T * T / 2 + 0.5 / df);\n}\n\nint main() {\n    long long T; int N;\n    cin >> T >> N;\n    const Rational<long long> center(1, T); // 45 度打ち出しの場合\n    using pf = pair<Rational<long long>,Rational<long long>>;\n    vector<pf> upper, lower, middle;\n    for (int i = 0; i < N; ++i) {\n        long long x, low, up; cin >> x >> low >> up;\n        Rational<long long> flow(low, x * (T-x));\n        Rational<long long> fup(up, x * (T-x));\n        if (fup < center) lower.push_back({flow, fup});\n        else if (flow > center) upper.push_back({flow, fup});\n        else middle.push_back({flow, fup});\n    }\n    sort(lower.begin(), lower.end(), [](const pf &a, const pf &b) {\n            return a.second < b.second;});\n    sort(upper.begin(), upper.end(), [](const pf &a, const pf &b) {\n            return a.first > b.first;});\n\n    long double res = 0.0;\n    Rational<long long> left = 0, right = 1000100; // right * 10^12/4 がオーバーフローしないように\n    for (auto inter : lower) {\n        if (left >= inter.first) continue;\n        res += cost(inter.second, T);\n        left = inter.second;\n    }\n    for (auto inter : upper) {\n        if (right <= inter.second) continue;\n        res += cost(inter.first, T);\n        right = inter.first;\n    }\n    bool remain = false;\n    for (auto inter : middle) {\n        if (left < inter.first && inter.second < right) remain = true;\n    }\n    if (remain) res += cost(center, T);\n    cout << fixed << setprecision(20) << res << endl;\n}\n\n",
                "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// floating\ntypedef long double Real;\nconst Real EPS = 1e-9;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint T,n;\nint x[125252], l[125252], h[125252];\n\nint main(){\n  scanf(\"%d%d\",&T,&n);\n  REP(i,n)scanf(\"%d%d%d\",x+i,l+i,h+i);\n  Real ans = 0.0;\n  \n  Real minimum = T / 2.0;\n  // DEBUG(minimum);\n  typedef pair<Real,Real> prr;\n\n  // 1. find max low > minimum, fly at v^2 = low (high desc order)\n  set<prr> S1, S2;\n  REP(i,n){\n    Real X = x[i];\n    Real L = l[i];\n    Real H = h[i];\n    Real low = X*(T-X) / (2.0*H);\n    Real high = X*(T-X) / (2.0*L);\n    // printf(\"low: %.18Lf, high: %.18Lf\\n\",low,high);\n    S1.insert(prr(low,high));\n    S2.insert(prr(high,low));\n  }\n  while(S1.size()){\n    prr P1 = *S1.rbegin();\n    Real p = P1.first;\n    if(p < minimum+EPS)break;\n    // printf(\"1. %.18Lf\\n\",p);\n    ans += sqrt(p + 0.25*T*T/p);\n    S1.erase(P1);\n    S2.erase(prr(P1.second, P1.first));\n    while(S2.size()){\n      prr P2 = *S2.rbegin();\n      Real low = P2.second;\n      Real high = P2.first;\n      if(p <= high+EPS){\n        S1.erase(prr(low,high));\n        S2.erase(prr(high,low));\n      }else{\n        break;\n      }\n    }\n  }\n\n  // 2. find min high < minimum, fly at v^2 = high (low asc order)\n  while(S2.size()){\n    prr P2 = *S2.begin();\n    Real p = P2.first;\n    if(p > minimum-EPS)break;\n    // printf(\"2. %.18Lf\\n\",p);\n    ans += sqrt(p + 0.25*T*T/p);\n    S2.erase(P2);\n    S1.erase(prr(P2.second, P2.first));\n    while(S1.size()){\n      prr P1 = *S1.begin();\n      Real low = P1.first;\n      Real high = P1.second;\n      if(p >= low-EPS){\n        S1.erase(prr(low,high));\n        S2.erase(prr(high,low));\n      }else{\n        break;\n      }\n    }\n  }\n\n  // 3. assert low <= minimum <= high, fly at v^2 = minimum\n  if(S1.size()){\n    Real p = minimum;\n    ans += sqrt(p + 0.25*T*T/p);\n    // printf(\"3. %.18Lf\\n\",p);\n  }\n\n  printf(\"%.18Lf\\n\", ans);\n\n  return 0;\n}\n\n",
                "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\nusing LD = long double;\n\nconst LD EPS = 1e-11;\n\nLD T;\nint N;\n\ninline LD alpha(LD x, LD y) {\n\treturn y / (x * (T - x));\n}\n\ninline LD tangle(LD x, LD y) {\n\treturn alpha(x, y) * T;\n}\n\ninline LD cost(LD tilt) {\n\treturn sqrt(T * (tilt * tilt + 1.) / (2 * tilt));\n}\n\nLD solve(const vector<pair<LD, LD>>&vec, LD& center) {\n\tLD res = 0.;\n\tset<LD>S;\n\tfor (auto &elm : vec) {\n\t\t//ここ怪しいなあ、バグか？\n\t\tif (S.lower_bound(elm.first) == S.lower_bound(elm.second)) {\n\t\t\tres += elm.first;\n\t\t\tS.insert(elm.first);\n\t\t\tcenter = elm.first;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void)\n{\n\tcin >> T >> N;\n\tbool is45 = false;\n\tvector<pair<LD, LD>>locos, hicos;\n\tvector<pair<LD, LD>>cencos;\n\tfor (int i = 0; i < N; ++i) {\n\t\tLD X, L, H;\n\t\tcin >> X >> L >> H;\n\t\tLD lo = tangle(X, L);\n\t\tLD hi = tangle(X, H);\n\t\tif (lo <= 1. && hi >= 1.) {\n\t\t\t//45°線を通る\n\t\t\tis45 = true;\n\t\t\tcencos.push_back({ cost(lo) + EPS,cost(hi) + EPS });\n\t\t\tcontinue;\n\t\t}\n\t\tif (lo < 1. && hi < 1.) {\n\t\t\t//45°未満\n\t\t\tlocos.push_back({ cost(hi) - EPS,cost(lo) + EPS });\n\t\t}\n\t\telse {\n\t\t\t//45°以上\n\t\t\thicos.push_back({ cost(lo) - EPS,cost(hi) + EPS });\n\t\t}\n\t}\n\tLD ans = 0;\n\tsort(locos.rbegin(), locos.rend());\n\tsort(hicos.rbegin(), hicos.rend());\n\tLD locen = 1e18, hicen = 1e18;\n\tans += solve(locos, locen);\n\tans += solve(hicos, hicen);\n\tcout.precision(15);\n\tif (is45) {\n\t\tfor (auto elm : cencos) {\n\t\t\tif (elm.first < locen && elm.second < hicen) {\n\t\t\t\tans += sqrt(T);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n",
                "#include <bits/stdc++.h>\ntypedef long long ll;\ntypedef long double ld;\nconst int INF=1e9,MOD=1e9+7;\nconst ll LINF=1e18;\nusing namespace std;\n//#define int long long\n#define int long double\n//template\ntypedef pair<int,int> P;\nstd::vector<P> up,down,med;\nint T;\nvoid change(int x,int l,int h){\n  int ka=(l/(x*(T-x)))*(T/2)*(T/2);\n  int jo=(h/(x*(T-x)))*(T/2)*(T/2);\n  if(ka>T/4)up.push_back(P(ka,jo));\n  else if(jo<T/4)down.push_back(P(jo,ka));\n  else med.push_back(P(ka,jo));\n}\nint speed(int h){\n  int a=4*h/(T*T);\n  int sain=a*T/sqrt(a*a*T*T+1);\n  return sqrt(2*a)*(T/2)/sain;\n}\n//main\nsigned main(){\n  int N;cin>>T>>N;\n  for(int i=0;i<N;i++){\n    int x,l,h;cin>>x>>l>>h;\n    change(x,l,h);\n  }\n  int ma=LINF,mi=-1;\n  sort(up.rbegin(),up.rend());\n  sort(down.begin(),down.end());\n  int ans=0;\n  for(auto p:up){\n    if(p.second>=ma)continue;\n    ans+=speed(p.first);\n    ma=p.first;\n    //cout<<p.first<<\" \"<<p.second<<endl;\n  }\n  for(auto p:down){\n    if(p.second<=mi)continue;\n    ans+=speed(p.first);\n    mi=p.first;\n    //cout<<p.first<<\" \"<<p.second<<endl;\n  }\n  bool f=false;\n  for(auto p:med)if(p.first>mi&&p.second<ma)f=true;\n  if(f)ans+=speed(T/4);\n  cout<<fixed<<setprecision(12)<<ans<<endl;\n}\n\n"
            ],
            "language": [
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2
            ]
        },
        "instruction": "Output the answer on one line. If the absolute error or relative error is $ 10 ^ {-9} $ or less, the answer is judged to be correct.",
        "generate_testcase": "\nimport traceback\nfrom string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\ndef generate_testcase(json_obj: dict) -> tuple[str, dict]:\n    \"\"\"\\n    Generate a test case based on the given json_obj.\\n\\n    Parameters:\\n    - json_obj (dict): The input JSON object containing problem parameters.\\n                       Must contain at least the key 'N' (number of rings).\\n\\n    Returns:\\n    - tuple[str, dict]: A tuple containing:\\n      - The first element is a string representing the test case in input format.\\n      - The second element is a dictionary representing the same test case.\\n    \"\"\"\n    import random\n\n    # Extract the number of rings; ensure it respects the problem limits.\n    N = json_obj.get(\"N\", 1)\n    N = max(1, min(N, 100_000))  # clamp to [1, 10^5]\n\n    # Generate the X positions of the rings.\n    # Constraints: 1 <= X_i < T <= 10^6.\n    # For the generator we keep all non‑size values < 10000,\n    # so we generate X_i in [1, 9998] (to leave room for T).\n    max_X_val = 9998\n    X = [random.randint(1, max_X_val) for _ in range(N)]\n    max_X = max(X) if X else 0\n\n    # Choose T (the landing x‑coordinate) larger than any X_i.\n    # Keep T < 10000 as well.\n    T = random.randint(max_X + 1, 9999) if max_X < 9999 else 9999\n\n    # Generate the vertical segment endpoints L_i and H_i.\n    # Constraints: 1 <= L_i < H_i <= 10^6, but we keep them < 10000.\n    L = []\n    H = []\n    for _ in range(N):\n        li = random.randint(1, 9998)            # L_i in [1, 9998]\n        hi = random.randint(li + 1, 9999)        # H_i in (L_i, 9999]\n        L.append(li)\n        H.append(hi)\n\n    # Build the textual representation of the input.\n    lines = [f\"{T} {N}\"]\n    for xi, li, hi in zip(X, L, H):\n        lines.append(f\"{xi} {li} {hi}\")\n    output_str = \"\\n\".join(lines) + \"\\n\"\n\n    # Build the dictionary representation.\n    rings = [{\"X\": xi, \"L\": li, \"H\": hi} for xi, li, hi in zip(X, L, H)]\n    output_dict = {\"T\": T, \"N\": N, \"rings\": rings}\n\n    return output_str, output_dict\n",
        "scale_range": 136,
        "output_type": "number",
        "is_output_unique": true,
        "difficulty_dict": {
            "0": 0,
            "1": 1,
            "2": 2,
            "3": 2,
            "4": 3,
            "5": 4,
            "6": 5,
            "7": 6,
            "8": 8,
            "9": 11,
            "10": 14,
            "11": 18,
            "12": 23,
            "13": 30,
            "14": 39,
            "15": 51,
            "16": 67,
            "17": 87,
            "18": 112,
            "19": 136
        },
        "params": {
            "N": {
                "min": 1,
                "max": 137,
                "base": 1.0
            },
            "difficulty": {
                "version": 1,
                "params": {
                    "dmax": 19,
                    "ema_beta": 0.0,
                    "activate_function": "base",
                    "history_len": 20,
                    "slope_scale": 0.05,
                    "age_scale": 100,
                    "alpha": 1.0,
                    "beta": 0.1
                }
            }
        }
    },
    "158_D. Ice Sculptures": {
        "name": "158_D. Ice Sculptures",
        "logic_description": "The Berland University is preparing to celebrate the 256-th anniversary of its founding! A specially appointed Vice Rector for the celebration prepares to decorate the campus. In the center of the campus n ice sculptures were erected. The sculptures are arranged in a circle at equal distances from each other, so they form a regular n-gon. They are numbered in clockwise order with numbers from 1 to n.\n\nThe site of the University has already conducted a voting that estimated each sculpture's characteristic of ti — the degree of the sculpture's attractiveness. The values of ti can be positive, negative or zero.\n\nWhen the university rector came to evaluate the work, he said that this might be not the perfect arrangement. He suggested to melt some of the sculptures so that: \n\n  * the remaining sculptures form a regular polygon (the number of vertices should be between 3 and n), \n  * the sum of the ti values of the remaining sculptures is maximized. \n\n\n\nHelp the Vice Rector to analyze the criticism — find the maximum value of ti sum which can be obtained in this way. It is allowed not to melt any sculptures at all. The sculptures can not be moved.",
        "raw_description": "The Berland University is preparing to celebrate the 256-th anniversary of its founding! A specially appointed Vice Rector for the celebration prepares to decorate the campus. In the center of the campus n ice sculptures were erected. The sculptures are arranged in a circle at equal distances from each other, so they form a regular n-gon. They are numbered in clockwise order with numbers from 1 to n.\n\nThe site of the University has already conducted a voting that estimated each sculpture's characteristic of ti — the degree of the sculpture's attractiveness. The values of ti can be positive, negative or zero.\n\nWhen the university rector came to evaluate the work, he said that this might be not the perfect arrangement. He suggested to melt some of the sculptures so that: \n\n  * the remaining sculptures form a regular polygon (the number of vertices should be between 3 and n), \n  * the sum of the ti values of the remaining sculptures is maximized. \n\n\n\nHelp the Vice Rector to analyze the criticism — find the maximum value of ti sum which can be obtained in this way. It is allowed not to melt any sculptures at all. The sculptures can not be moved.\n\nInput\n\nThe first input line contains an integer n (3 ≤ n ≤ 20000) — the initial number of sculptures. The second line contains a sequence of integers t1, t2, ..., tn, ti — the degree of the i-th sculpture's attractiveness ( - 1000 ≤ ti ≤ 1000). The numbers on the line are separated by spaces.\n\nOutput\n\nPrint the required maximum sum of the sculptures' attractiveness.\n\nExamples\n\nInput\n\n8\n1 2 -3 4 -5 5 2 3\n\n\nOutput\n\n14\n\n\nInput\n\n6\n1 -2 3 -4 5 -6\n\n\nOutput\n\n9\n\n\nInput\n\n6\n1 2 3 4 5 6\n\n\nOutput\n\n21\n\nNote\n\nIn the first sample it is best to leave every second sculpture, that is, leave sculptures with attractivenesses: 2, 4, 5 и 3.",
        "solutions": {
            "solution": [
                "#include <bits/stdc++.h>\nint count(int);\nint n, deg[1000000];\nint main(void) {\n  int i, maxsum = -1000000000;\n  scanf(\"%d\\n\", &n);\n  for (i = 0; i < n; i++) scanf(\"%d\", &deg[i]);\n  for (i = 1; i * 3 <= n; i++) {\n    if (n % i) continue;\n    maxsum = (maxsum > count(i)) ? maxsum : count(i);\n  }\n  printf(\"%d\\n\", maxsum);\n  return 0;\n}\nint count(int numSides) {\n  int sum[numSides], i;\n  for (i = 0; i < numSides; i++) sum[i] = 0;\n  for (i = 0; i < n; i++) sum[i % numSides] += deg[i];\n  int ms = -1000000000;\n  for (i = 0; i < numSides; i++) ms = (ms > sum[i]) ? ms : sum[i];\n  return ms;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  long res, q;\n  (cin >> n);\n  ;\n  vector<long> x(n);\n  for (auto i = (0); i < (n); i++) (cin >> x[i]);\n  ;\n  res = accumulate((x).begin(), (x).end(), (long)0);\n  for (auto j = (2); j < (n); j++) {\n    if (n % j == 0 && n / j >= 3) {\n      for (auto k = (0); k < (j); k++) {\n        q = 0;\n        for (int i = k; i < n; i += j) q += x[i];\n        if (q > res) res = q;\n      }\n    }\n  }\n  (cout << (res) << endl);\n  return 0;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  vector<int> atr;\n  cin >> n;\n  atr.resize(n);\n  int max = 0;\n  for (int i = 0; i < n; i++) {\n    cin >> atr[i];\n    max += atr[i];\n  }\n  for (int i = 2; 3 * i <= n; i++) {\n    if (n % i == 0 && n >= 3 * i) {\n      for (int j = 0; j < i; j++) {\n        int can = 0;\n        for (int k = j; k < n; k += i) {\n          can += atr[k];\n        }\n        if (can > max) max = can;\n      }\n    }\n  }\n  cout << max << endl;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, m, w, r, k, i, j, s, q, x, y, l, a[22000];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin >> n;\n  for (i = 1; i <= n; i++) {\n    cin >> a[i], s += a[i];\n    if (a[i] < 0) k = 1;\n  }\n  if (k == 0) {\n    cout << s;\n    return 0;\n  }\n  for (l = 2; l <= n; l++)\n    if (n % l == 0 && n / l >= 3)\n      for (j = 1; j <= l; j++) {\n        m = 0;\n        for (i = j; i <= n; i += l) m += a[i];\n        s = max(s, m);\n      }\n  cout << s;\n}\n",
                "#include <bits/stdc++.h>\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  long *value = new long[n];\n  for (int k = 0; k < n; k++) {\n    scanf(\"%ld\", value + k);\n  }\n  long output = 0, currentMax = -30000000;\n  for (int div = 1; div <= n / 3; div++) {\n    if (n % div != 0) {\n      continue;\n    }\n    for (int rem = 0; rem < div; rem++) {\n      output = 0;\n      for (int k = 0; k < n / div; k++) {\n        output += value[div * k + rem];\n      }\n      if (output > currentMax) {\n        currentMax = output;\n      }\n    }\n  }\n  printf(\"%ld\\n\", currentMax);\n  return 0;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  int *a = new int[n];\n  int max = 0;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    max += a[i];\n  }\n  for (int del = 2; del < n; del++) {\n    int vLeft = n / del;\n    if (n % del == 0 && vLeft > 2) {\n      for (int j = 0; j < n / vLeft + 1; j++) {\n        int done = 0;\n        int start = j;\n        int sum = 0;\n        while (done < vLeft) {\n          if (start >= n) start -= n;\n          sum += a[start];\n          start += del;\n          done++;\n        }\n        if (sum > max) max = sum;\n      }\n    }\n  }\n  cout << max;\n  return 0;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nint n, mayor = -30000000, vertices[30000], quitar[30000];\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &vertices[i]);\n  }\n  for (int i = 1; i * i <= n; i++) {\n    if (n % i == 0) {\n      if (n / i >= 3) {\n        for (int j = 0; j < n; j++) {\n          if (j % i == j)\n            quitar[j % i] = vertices[j];\n          else\n            quitar[j % i] += vertices[j];\n        }\n        for (int j = 0; j < i; j++) {\n          mayor = max(mayor, quitar[j]);\n        }\n      }\n      if (i >= 3) {\n        for (int j = 0; j < n; j++) {\n          if (j % (n / i) == j)\n            quitar[j % (n / i)] = vertices[j];\n          else\n            quitar[j % (n / i)] += vertices[j];\n        }\n        for (int j = 0; j < n / i; j++) {\n          mayor = max(mayor, quitar[j]);\n        }\n      }\n    }\n  }\n  printf(\"%d\", mayor);\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  vector<int> v(n);\n  for (int i = 0; i < n; i++) cin >> v[i];\n  int res = -1000000000;\n  for (int k = 3; k <= n; k++)\n    if (n % k == 0) {\n      int d = n / k;\n      for (int r = 0; r < d; r++) {\n        int sum = 0;\n        for (int i = r; i < n; i += d) sum += v[i];\n        res = max(res, sum);\n      }\n    }\n  cout << res << endl;\n  return 0;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int sz = 3e5 + 10;\n;\nconst ll inf = 1e18;\nconst int lim = 1 << 8;\nconst ll mod = 998244353;\nint n;\nll ar[sz];\nll br[sz];\nint main() {\n  while (scanf(\"%d\", &n) == 1) {\n    ll sum = 0, h;\n    for (int i = 0; i < n; i++) {\n      scanf(\"%lld\", &ar[i]);\n      sum += ar[i];\n    }\n    h = sum;\n    int c;\n    ll ans = sum;\n    for (int i = 2; i < n; i++) {\n      if (n % i != 0 || n / i < 3) continue;\n      for (int j = 0; j < i; j++) {\n        br[j] = 0;\n      }\n      for (int j = 0; j < n; j++) {\n        br[j % i] += ar[j];\n      }\n      ans = max(ans, *max_element(br, br + i));\n    }\n    printf(\"%lld\\n\", ans);\n    cerr << \"---\\n\";\n  }\n  return 0;\n}\n",
                "n=int(input())\ns=list(map(int,input().split()))\n\nmax=0\nfor i in range(n):\n    max+=s[i]\n\nfor i in range(2,n):\n    if n%i==0 and n//i>=3:\n        for j in range(i):\n            sum=0\n            x=j\n            while(x<n):\n                sum+=s[x]\n                x+=i\n            if sum>max:max=sum\nprint(max)"
            ],
            "language": [
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                3
            ]
        },
        "instruction": "Print the required maximum sum of the sculptures' attractiveness.",
        "generate_testcase": "\nimport traceback\nfrom string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nimport random\nfrom typing import Tuple, Dict, List\n\ndef generate_testcase(json_obj: dict) -> Tuple[str, dict]:\n    \"\"\"\\n    Generate a test case for the \"Berland University sculptures\" problem.\\n\\n    Parameters\\n    ----------\\n    json_obj : dict\\n        Must contain the key 'n' – the number of sculptures (3 ≤ n ≤ 20000).\\n\\n    Returns\\n    -------\\n    tuple\\n        (input_str, test_dict) where\\n        - input_str is the exact input format for the problem:\\n          \"<n>\\\\n<t1 t2 ... tn>\"\\n        - test_dict is a structured representation:\\n          {\"n\": n, \"t\": [t1, t2, ..., tn]}\\n    \"\"\"\n    n = int(json_obj[\"n\"])\n    if not (3 <= n <= 20000):\n        raise ValueError(\"n must satisfy 3 ≤ n ≤ 20000\")\n\n    # Initialise all attractiveness values randomly in the allowed range.\n    t: List[int] = [random.randint(-1000, 1000) for _ in range(n)]\n\n    # To make the instance a bit more interesting, try to embed one\n    # regular polygon with particularly high values.\n    # Find a divisor k of n such that 3 ≤ k < n (i.e., a non‑trivial polygon).\n    divisors = [d for d in range(3, n + 1) if n % d == 0 and d < n]\n    if divisors:\n        k = random.choice(divisors)          # number of vertices of the polygon\n        step = n // k                         # distance between successive vertices\n        offset = random.randint(0, step - 1)  # rotation of the polygon\n        # Raise the values of the selected vertices to a high positive range.\n        for i in range(k):\n            idx = (offset + i * step) % n\n            t[idx] = random.randint(800, 1000)   # guaranteed high contribution\n\n    # Build the string representation.\n    input_str = f\"{n}\\n\" + \" \".join(map(str, t))\n\n    # Build the dictionary representation.\n    test_dict = {\"n\": n, \"t\": t}\n\n    return input_str, test_dict\n",
        "scale_range": 471,
        "output_type": "number",
        "is_output_unique": true,
        "difficulty_dict": {
            "0": 0,
            "1": 1,
            "2": 2,
            "3": 2,
            "4": 3,
            "5": 4,
            "6": 5,
            "7": 6,
            "8": 8,
            "9": 11,
            "10": 14,
            "11": 18,
            "12": 23,
            "13": 30,
            "14": 39,
            "15": 51,
            "16": 67,
            "17": 87,
            "18": 112,
            "19": 146,
            "20": 190,
            "21": 247,
            "22": 321,
            "23": 418,
            "24": 471
        },
        "params": {
            "n": {
                "min": 3,
                "max": 474,
                "base": 1.0
            },
            "difficulty": {
                "version": 1,
                "params": {
                    "dmax": 24,
                    "ema_beta": 0.0,
                    "activate_function": "base",
                    "history_len": 20,
                    "slope_scale": 0.05,
                    "age_scale": 100,
                    "alpha": 1.0,
                    "beta": 0.1
                }
            }
        }
    },
    "1195_B. Sport Mafia": {
        "name": "1195_B. Sport Mafia",
        "logic_description": "Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. \n\nFor the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs n actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:\n\n  * the first option, in case the box contains at least one candy, is to take exactly one candy out and eat it. This way the number of candies in the box decreased by 1; \n  * the second option is to put candies in the box. In this case, Alya will put 1 more candy, than she put in the previous time. \n\n\n\nThus, if the box is empty, then it can only use the second option.\n\nFor example, one possible sequence of Alya's actions look as follows:\n\n  * put one candy into the box; \n  * put two candies into the box; \n  * eat one candy from the box; \n  * eat one candy from the box; \n  * put three candies into the box; \n  * eat one candy from the box; \n  * put four candies into the box; \n  * eat one candy from the box; \n  * put five candies into the box; \n\n\n\nThis way she will perform 9 actions, the number of candies at the end will be 11, while Alya will eat 4 candies in total.\n\nYou know the total number of actions n and the number of candies at the end k. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given n and k the answer always exists.\n\nPlease note, that during an action of the first option, Alya takes out and eats exactly one candy.",
        "raw_description": "Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. \n\nFor the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs n actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:\n\n  * the first option, in case the box contains at least one candy, is to take exactly one candy out and eat it. This way the number of candies in the box decreased by 1; \n  * the second option is to put candies in the box. In this case, Alya will put 1 more candy, than she put in the previous time. \n\n\n\nThus, if the box is empty, then it can only use the second option.\n\nFor example, one possible sequence of Alya's actions look as follows:\n\n  * put one candy into the box; \n  * put two candies into the box; \n  * eat one candy from the box; \n  * eat one candy from the box; \n  * put three candies into the box; \n  * eat one candy from the box; \n  * put four candies into the box; \n  * eat one candy from the box; \n  * put five candies into the box; \n\n\n\nThis way she will perform 9 actions, the number of candies at the end will be 11, while Alya will eat 4 candies in total.\n\nYou know the total number of actions n and the number of candies at the end k. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given n and k the answer always exists.\n\nPlease note, that during an action of the first option, Alya takes out and eats exactly one candy.\n\nInput\n\nThe first line contains two integers n and k (1 ≤ n ≤ 10^9; 0 ≤ k ≤ 10^9) — the total number of moves and the number of candies in the box at the end. \n\nIt's guaranteed, that for the given n and k the answer exists.\n\nOutput\n\nPrint a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. \n\nExamples\n\nInput\n\n\n1 1\n\n\nOutput\n\n\n0\n\nInput\n\n\n9 11\n\n\nOutput\n\n\n4\n\nInput\n\n\n5 0\n\n\nOutput\n\n\n3\n\nInput\n\n\n3 2\n\n\nOutput\n\n\n1\n\nNote\n\nIn the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate 0 candies.\n\nIn the second example the possible sequence of Alya's actions looks as follows: \n\n  * put 1 candy, \n  * put 2 candies, \n  * eat a candy, \n  * eat a candy, \n  * put 3 candies, \n  * eat a candy, \n  * put 4 candies, \n  * eat a candy, \n  * put 5 candies. \n\n\n\nThis way, she will make exactly n=9 actions and in the end the box will contain 1+2-1-1+3-1+4-1+5=11 candies. The answer is 4, since she ate 4 candies in total.",
        "solutions": {
            "solution": [
                "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  for (long long i = 1; i <= n; i++) {\n    if ((i * (i + 1)) / 2 >= k && i + (i * (i + 1)) / 2 - k == n) {\n      cout << (i * (i + 1)) / 2 - k << endl;\n      return 0;\n    }\n  }\n  assert(false);\n  return 0;\n}\n",
                "n,x=map(int,input().split())\nformula=0\ni=0\nif(n==1):\n    print(0)\nelse:\n    formula=1000000\n    while(abs(n-(i+formula))!=x):\n        i=i+1\n        formula=(i*(i+1))//2\n    print(abs(n-i))\n    \n\n    \n    \n    \n    \n    \n        \n    \n\n    \n\n\n\n        \n        \n\n",
                "n,k=map(int,input().split());print(round(n+1.5-(2*(n+k)+2.25)**0.5))",
                "n,k=map(int,input().split())\ni=1\nwhile i*(i+1)//2!=k+n-i:\n    i+=1\nprint(n-i)",
                "n, k = map(int, input().split())\n\nL = 0\nR = n * (n + 1) * 10\n\nwhile R - L > 1:\n    m = (L + R) // 2\n    if (m * (m + 1) // 2 - n + m) < k:\n        L = m\n    else:\n        R = m\nprint(n - R)\n",
                "a,b=map(int,input().split())\nprint(int(a-((9+8*(a+b))**0.5-3)/2))",
                "a, b = list(map(int,input().split()))\nl = 0\nr = a + 1\nwhile r - l > 1:\n    m = (r + l) // 2\n    #print(l, r)\n    if m * (m + 1) // 2 - (a - m) > b:\n        r = m\n    else:\n        l = m\nprint(a - l)",
                "n, k = map(int, input().split())\n\nfor i in range(1, n + 1):\n\tif (1 + i) * i // 2 - (n - i) == k:\n\t\tprint(n - i)\n\t\tbreak",
                "def binary_search(n,low,high,k):\n    index=0\n    while(low<=high):\n        mid=(low+high)//2\n        #print(mid)\n        if (mid*(mid+1))//2-k==n-mid:\n            return mid\n        elif (mid*(mid+1))//2-k>n-mid:\n            \n            high=mid-1\n        else:\n            low=mid+1\n    return index\n    \nn,k=map(int,input().split())\nprint(n-binary_search(n,0,n,k))\n\n        \n      ",
                "n, k = map(int, input().split())\nif n == 1:\n    print(0)\n    exit()\ncnt = 1\ni = 2\nstep = 1\nans = 0\nwhile step <= n: \n    if cnt > k:\n        ans += min(cnt - k, n - step)\n        step += cnt - k\n        cnt = k\n    cnt += i\n    step += 1\n    i += 1\nprint(ans)"
            ],
            "language": [
                2,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3
            ]
        },
        "instruction": "Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data.",
        "generate_testcase": "\nimport traceback\nfrom string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nimport math\nimport random\n\ndef generate_testcase(json_obj: dict) -> tuple[str, dict]:\n    \"\"\"\\n    Generate a test case for the \"Sport Mafia\" problem.\\n\\n    Parameters\\n    ----------\\n    json_obj : dict\\n        Must contain the key ``\"n\"`` – the total number of actions (1 ≤ n ≤ 10^9).\\n\\n    Returns\\n    -------\\n    tuple[str, dict]\\n        A pair (input_string, test_dict) where\\n        - ``input_string`` is a single line \"n k\" (with a trailing newline) ready\\n          to be fed to a solution program,\\n        - ``test_dict`` is {\"n\": n, \"k\": k}.\\n    \"\"\"\n    # ------------------------------------------------------------------ #\n    # 1. Extract the given parameter.\n    # ------------------------------------------------------------------ #\n    n = json_obj.get(\"n\")\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"Parameter 'n' must be a positive integer (1 ≤ n).\")\n\n    # ------------------------------------------------------------------ #\n    # 2. Choose a feasible number of “put” operations (p).\n    #    The first move is always a put, so p ≥ 1.\n    #    For a given p the final number of candies is\n    #        k = (p(p+1))/2 - (n - p) = (p² + 3p)/2 - n\n    #    We need 0 ≤ k ≤ 10⁹.\n    #\n    #    Condition k ≥ 0  →  (p² + 3p)/2 ≥ n\n    #    Condition k ≤ 10⁹ → (p² + 3p)/2 ≤ n + 10⁹\n    # ------------------------------------------------------------------ #\n    # Minimal p (ensuring k ≥ 0)\n    # Solve p² + 3p ≥ 2n → p ≥ (-3 + sqrt(9 + 8n)) / 2\n    p_min = math.ceil((-3 + math.sqrt(9 + 8 * n)) / 2)\n    p_min = max(1, p_min)                     # p must be at least 1\n\n    # Maximal p (ensuring k ≤ 10⁹)\n    # Solve p² + 3p ≤ 2(n + 10⁹) → p ≤ (-3 + sqrt(9 + 8·(n+10⁹))) / 2\n    max_val = 2 * (n + 10**9)                 # 2·(n + 10⁹)\n    p_max = math.floor((-3 + math.sqrt(9 + 4 * max_val)) / 2)\n    p_max = min(n, p_max)                     # p cannot exceed total moves n\n\n    # If the interval collapsed (should not happen for given constraints) fall back to p_min.\n    if p_max < p_min:\n        p = p_min\n    else:\n        p = random.randint(p_min, p_max)\n\n    # ------------------------------------------------------------------ #\n    # 3. Compute the corresponding final amount of candies k.\n    # ------------------------------------------------------------------ #\n    k = (p * p + 3 * p) // 2 - n\n    # Clamp just in case of rounding issues.\n    k = max(0, min(k, 10**9))\n\n    # ------------------------------------------------------------------ #\n    # 4. Build the required output formats.\n    # ------------------------------------------------------------------ #\n    input_str = f\"{n} {k}\\n\"\n    test_dict = {\"n\": n, \"k\": k}\n    return input_str, test_dict\n",
        "scale_range": 10000,
        "output_type": "number",
        "is_output_unique": true,
        "difficulty_dict": {
            "0": 0,
            "1": 2,
            "2": 3,
            "3": 4,
            "4": 7,
            "5": 10,
            "6": 17,
            "7": 27,
            "8": 43,
            "9": 69,
            "10": 110,
            "11": 176,
            "12": 281,
            "13": 450,
            "14": 721,
            "15": 1153,
            "16": 1845,
            "17": 2951,
            "18": 4722,
            "19": 7556,
            "20": 10000
        },
        "params": {
            "n": {
                "min": 1,
                "max": 10001,
                "base": 1.0
            },
            "difficulty": {
                "version": 1,
                "params": {
                    "dmax": 20,
                    "ema_beta": 0.0,
                    "activate_function": "base",
                    "history_len": 20,
                    "slope_scale": 0.05,
                    "age_scale": 100,
                    "alpha": 1.0,
                    "beta": 0.1
                }
            }
        }
    },
    "632_A. Grandma Laura and Apples": {
        "name": "632_A. Grandma Laura and Apples",
        "logic_description": "Grandma Laura came to the market to sell some apples. During the day she sold all the apples she had. But grandma is old, so she forgot how many apples she had brought to the market.\n\nShe precisely remembers she had n buyers and each of them bought exactly half of the apples she had at the moment of the purchase and also she gave a half of an apple to some of them as a gift (if the number of apples at the moment of purchase was odd), until she sold all the apples she had.\n\nSo each buyer took some integral positive number of apples, but maybe he didn't pay for a half of an apple (if the number of apples at the moment of the purchase was odd).\n\nFor each buyer grandma remembers if she gave a half of an apple as a gift or not. The cost of an apple is p (the number p is even).\n\nPrint the total money grandma should have at the end of the day to check if some buyers cheated her.",
        "raw_description": "Grandma Laura came to the market to sell some apples. During the day she sold all the apples she had. But grandma is old, so she forgot how many apples she had brought to the market.\n\nShe precisely remembers she had n buyers and each of them bought exactly half of the apples she had at the moment of the purchase and also she gave a half of an apple to some of them as a gift (if the number of apples at the moment of purchase was odd), until she sold all the apples she had.\n\nSo each buyer took some integral positive number of apples, but maybe he didn't pay for a half of an apple (if the number of apples at the moment of the purchase was odd).\n\nFor each buyer grandma remembers if she gave a half of an apple as a gift or not. The cost of an apple is p (the number p is even).\n\nPrint the total money grandma should have at the end of the day to check if some buyers cheated her.\n\nInput\n\nThe first line contains two integers n and p (1 ≤ n ≤ 40, 2 ≤ p ≤ 1000) — the number of the buyers and the cost of one apple. It is guaranteed that the number p is even.\n\nThe next n lines contains the description of buyers. Each buyer is described with the string half if he simply bought half of the apples and with the string halfplus if grandma also gave him a half of an apple as a gift.\n\nIt is guaranteed that grandma has at least one apple at the start of the day and she has no apples at the end of the day.\n\nOutput\n\nPrint the only integer a — the total money grandma should have at the end of the day.\n\nNote that the answer can be too large, so you should use 64-bit integer type to store it. In C++ you can use the long long integer type and in Java you can use long integer type.\n\nExamples\n\nInput\n\n2 10\nhalf\nhalfplus\n\n\nOutput\n\n15\n\n\nInput\n\n3 10\nhalfplus\nhalfplus\nhalfplus\n\n\nOutput\n\n55\n\nNote\n\nIn the first sample at the start of the day the grandma had two apples. First she sold one apple and then she sold a half of the second apple and gave a half of the second apple as a present to the second buyer.",
        "solutions": {
            "solution": [
                "n,k = map(int,input().split())\ns = [input() for i in range(n)]\ns = s[::-1]\nx = 0\n# print(s)\ncost = 0\nfor i in s:\n    if i == \"halfplus\":\n        x = 2*x+1\n        cost += x/2*k\n    else:\n        x = 2*x\n        cost += x/2*k\nprint(int(cost))",
                "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, p;\n  cin >> n >> p;\n  string s[n];\n  for (int i = 0; i < n; i++) cin >> s[i];\n  long long money = 0, num = 0;\n  for (int i = n - 1; i >= 0; i--) {\n    if (s[i] == \"halfplus\") {\n      money += p * num + p / 2;\n      num = num * 2 + 1;\n    } else {\n      money += p * num;\n      num *= 2;\n    }\n  }\n  cout << money << endl;\n}\n",
                "n, price = map(int, input().split())\nhistory = []\nans = 0\ncnt = 0\nfor i in range(n):\n    history.append(input())\nfor s in history[::-1]:\n    if s == 'halfplus':\n        cnt = cnt * 2 + 1\n    else:\n        cnt *= 2\n    ans += cnt / 2 * price\nprint(int(ans))",
                "#include <bits/stdc++.h>\nusing namespace std;\nconst int SIZE = 1024;\nint n, k, a[SIZE];\nlong long ans, cur;\nint main() {\n  cin >> n >> k;\n  for (int i = n; i >= 1; i--) {\n    string ii;\n    cin >> ii;\n    if (ii == \"half\") {\n      a[i] = 1;\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (a[i]) {\n      cur *= 2;\n    } else {\n      cur = cur * 2 + 1;\n    }\n    ans += cur;\n  }\n  cout << ans * k / 2;\n  return 0;\n}\n",
                "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\n#pragma GCC optimization(\"unroll-loops\")\nusing namespace std;\nconst long long MOD = 1e+9 + 7;\nconst long long INF = 0x7f7f7f7f7f7f7f7f;\nconst int INFi = 0x7f7f7f7f;\nconst long long MAXN = 1e+5 + 7;\nvector<long long> adj[MAXN];\nlong long visit[MAXN] = {};\nint dx8[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy8[] = {1, 1, 0, -1, -1, -1, 0, 1};\nint dx4[] = {0, 1, 0, -1}, dy4[] = {1, 0, -1, 0};\nint t = 1;\nlong long n, p;\nstring second[100];\nvoid MAIN() {\n  cin >> n >> p;\n  long long ans = 0;\n  long long ans1 = 0;\n  for (long long i = 0; i < n; i++) cin >> second[i];\n  for (long long i = n - 1; i >= 0; i--) {\n    if (second[i] == \"half\") {\n      ans *= 2;\n    } else {\n      ans *= 2;\n      ans++;\n    }\n  }\n  for (long long i = 0; i < n; i++) {\n    if (second[i] == \"half\") {\n      ans1 += ans / 2 * p;\n      ans /= 2;\n    } else {\n      ans1 += ans / 2 * p + p / 2;\n      ans /= 2;\n    }\n  }\n  cout << ans1 << endl;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cout << fixed;\n  cout << setprecision(10);\n  ;\n  mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n  ;\n  while (t--) {\n    MAIN();\n  }\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nint gcd(int a, int b, int &x, int &y) {\n  if (a == 0) {\n    x = 0;\n    y = 1;\n    return b;\n  }\n  int x1, y1;\n  int g = gcd(b % a, a, x1, y1);\n  x = y1 - (b / a) * x1;\n  y = x1;\n  return g;\n}\nbool diofant_any(int a, int b, int c, int &x, int &y, int &g) {\n  g = gcd(abs(a), abs(b), x, y);\n  if (c % g != 0) return false;\n  x *= c / g;\n  y *= c / g;\n  if (a < 0) x *= -1;\n  if (b < 0) y *= -1;\n  return true;\n}\nvoid solve() {\n  int n, p;\n  cin >> n >> p;\n  string s;\n  long long sum = 0, halC = 0;\n  vector<int> v(n, 0);\n  int count = 0;\n  for (int i = n - 1; i >= 0; i--) {\n    cin >> s;\n    if (s == \"half\")\n      v[i] = 1;\n    else {\n      count++;\n    }\n  }\n  for (size_t i = 0; i < n; i++) {\n    if (v[i]) {\n      sum *= 2;\n    } else\n      sum = 2 * sum + 1;\n  }\n  cout << (2 * sum - count) * p / 2;\n}\nint main() {\n  int t = 1;\n  for (int i = 0; i < t; i++) {\n    solve();\n    cout << '\\n';\n  }\n  return 0;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nint l[45];\nint main() {\n  long long n, p;\n  cin >> n >> p;\n  for (int i = 0; i < n; i++) {\n    char s[23];\n    scanf(\"%s\", s);\n    l[i] = strlen(s);\n  }\n  long long ans = 0;\n  double now = 0;\n  for (int i = n - 1; i >= 0; i--) {\n    if (l[i] == 8) {\n      now += now + 1;\n    } else\n      now *= 2;\n    ans += ((now) / 2) * p;\n  }\n  cout << ans << endl;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nstring st[42];\nint main() {\n  int n, p;\n  scanf(\"%d %d\", &n, &p);\n  for (int i = 0; i < n; i++) {\n    cin >> st[i];\n  }\n  double half = 1;\n  double noa = 1;\n  for (int i = n - 2; i >= 0; i--) {\n    if (st[i].length() > 4) {\n      half++;\n      noa += 0.5;\n      noa *= 2;\n    } else {\n      noa *= 2;\n    }\n  }\n  printf(\"%lld\", (long long)((noa - (half / 2)) * p));\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1e9 + 7;\nint d[1000111], n, p;\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> p;\n  for (int i = 1; i <= n; i++) {\n    string x;\n    cin >> x;\n    if (x == \"half\")\n      d[i] = 0;\n    else\n      d[i] = 1;\n  }\n  long long res = p * 0.5, ans = 1;\n  for (int i = n - 1; i >= 1; i--) {\n    res += ((d[i] ? (0.5 * p) : 0) + p * ans);\n    ans *= 2;\n    ans += d[i];\n  }\n  cout << res;\n}\n",
                "#include <bits/stdc++.h>\nbool flag[50];\nchar s[10];\nint main() {\n  int n, p;\n  scanf(\"%d%d\", &n, &p);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%s\", s);\n    flag[i] = strcmp(s, \"half\");\n  }\n  double ans = flag[n - 1] ? 0.5 : 1;\n  long long count = 1;\n  for (int i = n - 2; i >= 0; i--) {\n    if (flag[i]) {\n      ans += count + 0.5;\n      count = 2 * count + 1;\n    } else {\n      ans += count;\n      count *= 2;\n    }\n  }\n  printf(\"%.0lf\\n\", ans * p);\n  return 0;\n}\n"
            ],
            "language": [
                3,
                2,
                3,
                2,
                2,
                2,
                2,
                2,
                2,
                2
            ]
        },
        "instruction": "Print the only integer a — the total money grandma should have at the end of the day.\n\nNote that the answer can be too large, so you should use 64-bit integer type to store it. In C++ you can use the long long integer type and in Java you can use long integer type.",
        "generate_testcase": "\nimport traceback\nfrom string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nimport random\nfrom typing import Tuple, Dict, List\n\ndef generate_testcase(json_obj: dict) -> Tuple[str, dict]:\n    \"\"\"\\n    Generate a test case for the \"Grandma Laura and Apples\" problem.\\n\\n    Parameters\\n    ----------\\n    json_obj : dict\\n        Must contain the key \"n\" (number of buyers, 1 ≤ n ≤ 40).\\n        May optionally contain \"p\" (price of one apple, even and 2 ≤ p ≤ 1000).\\n        If \"p\" is missing, a random even price in the allowed range is chosen.\\n\\n    Returns\\n    -------\\n    tuple (output_str, output_dict)\\n        output_str : str\\n            The test case formatted exactly as required by the problem input.\\n        output_dict : dict\\n            A structured representation of the same test case.\\n    \"\"\"\n    # ----------------------------------------------------------------------\n    # Extract parameters, with validation\n    # ----------------------------------------------------------------------\n    n = int(json_obj.get(\"n\", 1))\n    if not (1 <= n <= 40):\n        raise ValueError(f\"n must satisfy 1 ≤ n ≤ 40, got {n}\")\n\n    if \"p\" in json_obj:\n        p = int(json_obj[\"p\"])\n        # Ensure p is even and within the bounds\n        p = max(2, min(1000, p))\n        if p % 2 != 0:\n            p += 1  # make it even (alternatively could randomise)\n    else:\n        # Choose a random even price in [2, 1000]\n        p = random.randrange(2, 1001, 2)\n\n    # ----------------------------------------------------------------------\n    # Generate a random feasible sequence of buyers\n    # ----------------------------------------------------------------------\n    # Randomly pick \"half\" or \"halfplus\" for each buyer,\n    # but guarantee at least one \"halfplus\" (otherwise the initial apple count would be zero).\n    buyers: List[str] = [random.choice([\"half\", \"halfplus\"]) for _ in range(n)]\n    if all(b == \"half\" for b in buyers):\n        # Force at least one halfplus\n        idx = random.randrange(n)\n        buyers[idx] = \"halfplus\"\n\n    # ----------------------------------------------------------------------\n    # Verify feasibility (compute the initial number of apples)\n    # ----------------------------------------------------------------------\n    # Reverse simulation: start with 0 apples after the last buyer,\n    # then reconstruct the amount before each buyer.\n    cur = 0\n    for b in reversed(buyers):\n        if b == \"half\":\n            cur = cur * 2\n        else:               # \"halfplus\"\n            cur = cur * 2 + 1\n\n    # cur is the initial number of apples; must be >= 1.\n    # If somehow it is 0 (which can only happen when all are \"half\"),\n    # we have already forced a \"halfplus\", so this should never happen.\n    # Still, keep a safety check.\n    if cur == 0:\n        buyers[0] = \"halfplus\"\n        cur = 1\n\n    # ----------------------------------------------------------------------\n    # Build the textual representation of the test case\n    # ----------------------------------------------------------------------\n    lines = [f\"{n} {p}\"] + buyers\n    output_str = \"\\n\".join(lines) + \"\\n\"\n\n    # ----------------------------------------------------------------------\n    # Build the dictionary representation of the test case\n    # ----------------------------------------------------------------------\n    output_dict = {\n        \"n\": n,\n        \"p\": p,\n        \"buyers\": buyers\n    }\n\n    return output_str, output_dict\n",
        "scale_range": 39,
        "output_type": "number",
        "is_output_unique": true,
        "difficulty_dict": {
            "0": 0,
            "1": 1,
            "2": 2,
            "3": 4,
            "4": 5,
            "5": 6,
            "6": 8,
            "7": 9,
            "8": 10,
            "9": 12,
            "10": 13,
            "11": 14,
            "12": 16,
            "13": 17,
            "14": 18,
            "15": 20,
            "16": 21,
            "17": 22,
            "18": 24,
            "19": 25,
            "20": 26,
            "21": 28,
            "22": 29,
            "23": 30,
            "24": 32,
            "25": 33,
            "26": 34,
            "27": 36,
            "28": 37,
            "29": 38
        },
        "params": {
            "n": {
                "min": 1,
                "max": 40,
                "base": 1.0
            },
            "difficulty": {
                "version": 1,
                "params": {
                    "dmax": 29,
                    "ema_beta": 0.0,
                    "activate_function": "base",
                    "history_len": 20,
                    "slope_scale": 0.05,
                    "age_scale": 100,
                    "alpha": 1.0,
                    "beta": 0.1
                }
            }
        }
    },
    "883_C. Downloading B++": {
        "name": "883_C. Downloading B++",
        "logic_description": "Only T milliseconds left before the start of well-known online programming contest Codehorses Round 2017.\n\nPolycarp needs to download B++ compiler to take part in the contest. The size of the file is f bytes.\n\nPolycarp's internet tariff allows to download data at the rate of one byte per t0 milliseconds. This tariff is already prepaid, and its use does not incur any expense for Polycarp. In addition, the Internet service provider offers two additional packages:\n\n  * download a1 bytes at the rate of one byte per t1 milliseconds, paying p1 burles for the package; \n  * download a2 bytes at the rate of one byte per t2 milliseconds, paying p2 burles for the package. \n\n\n\nPolycarp can buy any package many times. When buying a package, its price (p1 or p2) is prepaid before usage. Once a package is bought it replaces the regular tariff until package data limit is completely used. After a package is consumed Polycarp can immediately buy a new package or switch to the regular tariff without loosing any time. While a package is in use Polycarp can't buy another package or switch back to the regular internet tariff.\n\nFind the minimum amount of money Polycarp has to spend to download an f bytes file no more than in T milliseconds.\n\nNote that because of technical reasons Polycarp can download only integer number of bytes using regular tariff and both packages. I.e. in each of three downloading modes the number of downloaded bytes will be integer. It means that Polycarp can't download a byte partially using the regular tariff or/and both packages.",
        "raw_description": "Only T milliseconds left before the start of well-known online programming contest Codehorses Round 2017.\n\nPolycarp needs to download B++ compiler to take part in the contest. The size of the file is f bytes.\n\nPolycarp's internet tariff allows to download data at the rate of one byte per t0 milliseconds. This tariff is already prepaid, and its use does not incur any expense for Polycarp. In addition, the Internet service provider offers two additional packages:\n\n  * download a1 bytes at the rate of one byte per t1 milliseconds, paying p1 burles for the package; \n  * download a2 bytes at the rate of one byte per t2 milliseconds, paying p2 burles for the package. \n\n\n\nPolycarp can buy any package many times. When buying a package, its price (p1 or p2) is prepaid before usage. Once a package is bought it replaces the regular tariff until package data limit is completely used. After a package is consumed Polycarp can immediately buy a new package or switch to the regular tariff without loosing any time. While a package is in use Polycarp can't buy another package or switch back to the regular internet tariff.\n\nFind the minimum amount of money Polycarp has to spend to download an f bytes file no more than in T milliseconds.\n\nNote that because of technical reasons Polycarp can download only integer number of bytes using regular tariff and both packages. I.e. in each of three downloading modes the number of downloaded bytes will be integer. It means that Polycarp can't download a byte partially using the regular tariff or/and both packages.\n\nInput\n\nThe first line contains three integer numbers f, T and t0 (1 ≤ f, T, t0 ≤ 107) — size of the file to download (in bytes), maximal time to download the file (in milliseconds) and number of milliseconds to download one byte using the regular internet tariff.\n\nThe second line contains a description of the first additional package. The line contains three integer numbers a1, t1 and p1 (1 ≤ a1, t1, p1 ≤ 107), where a1 is maximal sizes of downloaded data (in bytes), t1 is time to download one byte (in milliseconds), p1 is price of the package (in burles).\n\nThe third line contains a description of the second additional package. The line contains three integer numbers a2, t2 and p2 (1 ≤ a2, t2, p2 ≤ 107), where a2 is maximal sizes of downloaded data (in bytes), t2 is time to download one byte (in milliseconds), p2 is price of the package (in burles).\n\nPolycarp can buy any package many times. Once package is bought it replaces the regular tariff until package data limit is completely used. While a package is in use Polycarp can't buy another package or switch back to the regular internet tariff.\n\nOutput\n\nPrint the minimum amount of money that Polycarp needs to pay to download B++ compiler no more than in T milliseconds. If there is no solution, print the only integer -1.\n\nExamples\n\nInput\n\n120 964 20\n26 8 8\n13 10 4\n\n\nOutput\n\n40\n\n\nInput\n\n10 200 20\n1 1 1\n2 2 3\n\n\nOutput\n\n0\n\n\nInput\n\n8 81 11\n4 10 16\n3 10 12\n\n\nOutput\n\n28\n\n\nInput\n\n8 79 11\n4 10 16\n3 10 12\n\n\nOutput\n\n-1\n\nNote\n\nIn the first example Polycarp has to buy the first additional package 5 times and do not buy the second additional package. He downloads 120 bytes (of total 26·5 = 130 bytes) in 120·8 = 960 milliseconds (960 ≤ 964). He spends 8·5 = 40 burles on it.\n\nIn the second example Polycarp has enough time to download 10 bytes. It takes 10·20 = 200 milliseconds which equals to upper constraint on download time.\n\nIn the third example Polycarp has to buy one first additional package and one second additional package.\n\nIn the fourth example Polycarp has no way to download the file on time.",
        "solutions": {
            "solution": [
                "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int N = 1e7 + 5;\nconstexpr long long LINF = 1e18;\nint main() {\n  ios::sync_with_stdio(false);\n  long long f, t, t0;\n  cin >> f >> t >> t0;\n  long long a1, t1, p1;\n  cin >> a1 >> t1 >> p1;\n  long long a2, t2, p2;\n  cin >> a2 >> t2 >> p2;\n  auto bs = [&](long long data, long long time) -> long long {\n    if (data * t0 > time && data * t2 > time) return LINF;\n    long long l = 0, r = (data + (a2 - 1)) / a2;\n    while (l < r) {\n      long long mid = (l + r) >> 1;\n      long long usage = min(mid * a2, data);\n      if (usage * t2 + (data - usage) * t0 <= time)\n        r = mid;\n      else\n        l = mid + 1;\n    }\n    return l * p2;\n  };\n  long long ans = LINF;\n  for (int usage = 0; usage < f + 1; usage++) {\n    long long lfdata = f - usage, lftime = t - usage * t1,\n              price = (usage + (a1 - 1)) / a1 * p1;\n    if (t0 <= t2) {\n      if (lfdata * t0 <= lftime) ans = min(ans, price);\n    } else\n      ans = min(ans, price + bs(lfdata, lftime));\n  }\n  cout << (ans != LINF ? ans : -1) << endl;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nconst long long inf = 1e18;\nlong long f, T, t0, a1, t1, p1, a2, t2, p2, resF, resT, ans = inf;\nint main() {\n  cin >> f >> T >> t0 >> a1 >> t1 >> p1 >> a2 >> t2 >> p2;\n  if (t1 > t2) swap(a1, a2), swap(p1, p2), swap(t1, t2);\n  for (int i = 0; (i - 1) * a1 <= f; ++i) {\n    resF = f - min(i * a1, f), resT = T - min(i * a1, f) * t1;\n    if (resF == 0) {\n      if (resT < 0) break;\n      ans = min(ans, i * p1);\n      break;\n    }\n    if (t0 * resF > resT && t2 * resF > resT) continue;\n    if (t0 * resF <= resT)\n      ans = min(ans, i * p1);\n    else {\n      long long x = (resT - t0 * resF) / (t2 - t0) +\n                    ((resT - t0 * resF) % (t2 - t0) == 0 ? 0 : 1);\n      long long pk = (x / a2) + (x % a2 == 0 ? 0 : 1);\n      ans = min(ans, pk * p2 + i * p1);\n    }\n  }\n  ans = max(ans, (long long)0);\n  printf(\"%lld\\n\", ans < inf ? ans : -1);\n  return 0;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nconst long long inf = 1e18;\nlong long first, T, mt;\nlong long t[2], p[2], a[2];\nlong long get(long long ile, long long czas) {\n  if (ile == 0) {\n    return 0;\n  }\n  if (min(ile * mt, ile * t[1]) > czas) {\n    return inf;\n  }\n  if (ile * mt <= czas) {\n    return 0;\n  }\n  long long st = 0, en = ile, mid = (st + en) / 2, res = inf;\n  while (st <= en) {\n    long long il = min(ile, mid * a[1]);\n    if (il * t[1] + (ile - il) * mt <= czas) {\n      res = min(res, mid);\n      en = mid - 1;\n    } else {\n      st = mid + 1;\n    }\n    mid = (st + en) / 2;\n  }\n  return res * p[1];\n}\nint main() {\n  scanf(\"%lld%lld%lld\", &first, &T, &mt);\n  for (int i = 0; i < 2; i++) {\n    scanf(\"%lld%lld%lld\", a + i, t + i, p + i);\n  }\n  if (t[0] > t[1]) {\n    swap(a[0], a[1]);\n    swap(t[0], t[1]);\n    swap(p[0], p[1]);\n  }\n  if (min(mt, t[0]) * first > T) {\n    printf(\"-1\\n\");\n    return 0;\n  }\n  if (mt * first <= T) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  long long res = inf;\n  for (long long i = 0; (i - 1) * a[0] * t[0] + 1 <= T; i++) {\n    long long ile = min(first, a[0] * i);\n    long long cena = i * p[0] + get(first - ile, T - ile * t[0]);\n    res = min(res, cena);\n  }\n  printf(\"%lld\\n\", res);\n  return 0;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nconst long double pi = acos(-1);\ntemplate <typename T>\nT qpow(T x, int y) {\n  T ans = {};\n  for (; y; x = x * x, y >>= 1)\n    if (y & 1) ans = ans * x;\n  return ans;\n}\nint gi() {\n  int w = 0;\n  bool q = 1;\n  char c = getchar();\n  while ((c < '0' || c > '9') && c != '-') c = getchar();\n  if (c == '-') q = 0, c = getchar();\n  while (c >= '0' && c <= '9') w = w * 10 + c - '0', c = getchar();\n  return q ? w : -w;\n}\nlong long F, T, t0, a1, t1, p1, a2, t2, p2, ans = 1LL << 60;\ninline void work() {\n  long long i, f, t, x;\n  for (i = 0;; i++) {\n    f = F - a1 * i;\n    t = T - a1 * t1 * i;\n    if (f <= 0) {\n      if (F * t1 <= T) ans = min(ans, i * p1);\n      break;\n    }\n    if (t <= 0) break;\n    if (f * t0 <= t)\n      ans = min(ans, i * p1);\n    else if (f * t2 <= t) {\n      x = (f * t0 - t - 1) / (t0 - t2) + 1;\n      ans = min(ans, i * p1 + ((x - 1) / a2 + 1) * p2);\n    }\n  }\n}\nint main() {\n  F = gi(), T = gi(), t0 = gi();\n  a1 = gi(), t1 = gi(), p1 = gi();\n  a2 = gi(), t2 = gi(), p2 = gi();\n  work();\n  swap(a1, a2);\n  swap(t1, t2);\n  swap(p1, p2);\n  work();\n  cout << (ans == 1LL << 60 ? -1 : ans) << endl;\n  return 0;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nlong long f, T, t0, t1, p1, a1, t2, p2, a2;\nconst long long inf = 1e18;\nlong long bst = inf;\nvoid load() {\n  cin >> f >> T >> t0;\n  cin >> a1 >> t1 >> p1 >> a2 >> t2 >> p2;\n}\nlong long mlt(long long a, long long b, long long c) {\n  long double res = a;\n  res *= b;\n  res *= c;\n  res = min(res, 1e18l);\n  return (long long)(res);\n}\nvoid check(long long y) {\n  if (y * a1 >= f) {\n    if (min(a1 * y, f) * t1 <= ::T) {\n      bst = min(bst, y * p1);\n    }\n    return;\n  }\n  if (mlt(y, t1, a1) > ::T) return;\n  long long T = ::T - a1 * y * t1;\n  long long x = f - y * a1;\n  if (x * t0 + mlt(y, t1, a1) <= ::T) {\n    bst = min(bst, p1 * y);\n    return;\n  }\n  if (t2 >= t0) return;\n  long long up = x * t0 - T;\n  long long dw = a2 * (t0 - t2);\n  long long cnt = (up + dw - 1) / dw;\n  long long TT = max(0ll, f - y * a1 - cnt * a2) * t0 + y * t1 * a1 +\n                 min(cnt * a2, f - a1 * y) * t2;\n  if (TT > ::T) return;\n  long long F = max(0ll, f - y * a1 - cnt * a2) + y * a1 + cnt * a2;\n  if (F < f) return;\n  bst = min(bst, y * p1 + cnt * p2);\n}\nvoid solve() {\n  for (int i = 0; i <= f; i++) {\n    check(i);\n  }\n  swap(a1, a2);\n  swap(p1, p2);\n  swap(t1, t2);\n  for (int i = 0; i <= f; i++) {\n    check(i);\n  }\n  if (bst == inf) bst = -1;\n  cout << bst << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  load();\n  solve();\n  return 0;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\ninline long long read() {\n  long long x = 0, f = 1;\n  char c = getchar();\n  while (!isdigit(c)) {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (isdigit(c)) {\n    x = (x << 1) + (x << 3) + c - 48;\n    c = getchar();\n  }\n  return x * f;\n}\nint main() {\n  long long F = read(), T = read();\n  long long t0 = read();\n  long long a1 = read(), t1 = read(), p1 = read();\n  long long a2 = read(), t2 = read(), p2 = read();\n  if (t1 > t2) swap(t1, t2), swap(a1, a2), swap(p1, p2);\n  long long ans = 1e18;\n  for (int i = 0; (i - 1) * a1 <= F; ++i) {\n    long long resF = F - min(i * a1, F), resT = T - min(i * a1, F) * t1;\n    if (resF == 0) {\n      if (resT < 0) break;\n      ans = min(ans, i * p1);\n      break;\n    }\n    if (t0 * resF > resT && t2 * resF > resT) continue;\n    if (t0 * resF <= resT)\n      ans = min(ans, i * p1);\n    else {\n      long long x = (resT - t0 * resF) / (t2 - t0) +\n                    ((resT - t0 * resF) % (t2 - t0) == 0 ? 0 : 1);\n      long long pk = (x / a2) + (x % a2 == 0 ? 0 : 1);\n      ans = min(ans, pk * p2 + i * p1);\n    }\n  }\n  ans = max(ans, 0ll);\n  printf(\"%lld\\n\", ans < 1e18 ? ans : -1);\n  return 0;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nvoid read(long long &x) { scanf(\"%lld\", &x); }\nvoid print(long long x) { printf(\"%lld \", x); }\nvoid println(long long x) { printf(\"%lld\\n\", x); }\nlong long f, t, t0, a1, a2, t1, t2, p1, p2, mx1, mx2, ans = 1e15, r, tot;\nint main() {\n  cin >> f >> t >> t0 >> a1 >> t1 >> p1 >> a2 >> t2 >> p2;\n  mx1 = (f + a1 - 1) / a1;\n  mx2 = (f + a2 - 1) / a2;\n  r = mx2;\n  for (long long i = 0; i <= mx1; i++) {\n    while (r > 0 && i * a1 + (r - 1) * a2 >= f) r--;\n    while (r > 0 && i * a1 * t1 + (r - 1) * a2 * t2 +\n                            max(0LL, f - i * a1 - (r - 1) * a2) * t0 <=\n                        t)\n      r--;\n    if (i * a1 >= f)\n      tot = f * t1;\n    else if (i * a1 <= f && i * a1 + r * a2 >= f)\n      tot = i * a1 * t1 + (f - i * a1) * t2;\n    else\n      tot = i * a1 * t1 + r * a2 * t2 + (f - i * a1 - r * a2) * t0;\n    if (tot <= t) ans = min(ans, i * p1 + r * p2);\n  }\n  r = mx1;\n  for (long long i = 0; i <= mx2; i++) {\n    while (r > 0 && i * a2 + (r - 1) * a1 >= f) r--;\n    while (r > 0 && i * a2 * t2 + (r - 1) * a1 * t1 +\n                            max(0LL, f - i * a2 - (r - 1) * a1) * t0 <=\n                        t)\n      r--;\n    if (i * a2 >= f)\n      tot = f * t2;\n    else if (i * a2 <= f && i * a2 + r * a1 >= f)\n      tot = i * a2 * t2 + (f - i * a2) * t1;\n    else\n      tot = i * a2 * t2 + r * a1 * t1 + (f - i * a2 - r * a1) * t0;\n    if (tot <= t) ans = min(ans, i * p2 + r * p1);\n  }\n  if (ans == 1e15) ans = -1;\n  cout << ans;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long f, t, t0, a1, t1, p1, a2, t2, p2, i, j;\n  long long tt, ff, minn = 1e18;\n  cin >> f >> t >> t0 >> a1 >> t1 >> p1 >> a2 >> t2 >> p2;\n  if (t1 > t2) swap(t1, t2), swap(a1, a2), swap(p1, p2);\n  for (i = 0; a1 * i < f; i++) {\n    ff = f - i * a1;\n    tt = t - i * a1 * t1;\n    if (ff * t2 <= tt || ff * t0 <= tt) {\n      if (t0 <= t2 || ff * t0 <= tt || ff * t2 > tt)\n        j = 0;\n      else {\n        j = (ff * t0 - tt) / (a2 * (t0 - t2));\n        if ((j * a2 * t2 + (ff - j * a2) * t0) > tt) j++;\n      }\n      if (p1 * i + p2 * j < minn) minn = p1 * i + p2 * j;\n    }\n  }\n  if (f * t1 <= t && (f + a1 - 1) / a1 * p1 < minn)\n    minn = (f + a1 - 1) / a1 * p1;\n  if (minn == 1e18)\n    cout << -1;\n  else\n    cout << minn;\n  return 0;\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int f, t, t0;\n  cin >> f >> t >> t0;\n  int a1, t1, p1, a2, t2, p2;\n  cin >> a1 >> t1 >> p1 >> a2 >> t2 >> p2;\n  long long ans = LLONG_MAX;\n  for (int i = 0; i <= (f + a1 - 1) / a1; i++) {\n    long long cost = p1 * 1ll * i;\n    int a_download = min(f, i * a1);\n    int rem = f - a_download;\n    long long T = t1 * 1ll * a_download;\n    if (T > t) continue;\n    if (t0 <= t2) {\n      T += rem * 1ll * t0;\n      if (T <= t && ans > cost) ans = cost;\n      continue;\n    }\n    int lo = 0, hi = (rem + a2 - 1) / a2, an = -1;\n    while (lo <= hi) {\n      int mid = (long long)(lo + hi) >> 1;\n      int to_download = min(rem, mid * a2);\n      if (T + to_download * 1ll * t2 + (rem - to_download) * 1ll * t0 <= t) {\n        an = mid;\n        hi = mid - 1;\n      } else\n        lo = mid + 1;\n    }\n    if (an == -1) continue;\n    if (ans > cost + an * 1ll * p2) {\n      ans = cost + an * 1ll * p2;\n    }\n  }\n  swap(a1, a2);\n  swap(t1, t2);\n  swap(p1, p2);\n  for (int i = 0; i <= (f + a1 - 1) / a1; i++) {\n    long long cost = p1 * 1ll * i;\n    int a_download = min(f, i * a1);\n    int rem = f - a_download;\n    long long T = t1 * 1ll * a_download;\n    if (T > t) continue;\n    if (t0 <= t2) {\n      T += rem * 1ll * t0;\n      if (T <= t && ans > cost) ans = cost;\n      continue;\n    }\n    int lo = 0, hi = (rem + a2 - 1) / a2, an = -1;\n    while (lo <= hi) {\n      int mid = (long long)(lo + hi) >> 1;\n      int to_download = min(rem, mid * a2);\n      if (T + to_download * 1ll * t2 + (rem - to_download) * 1ll * t0 <= t) {\n        an = mid;\n        hi = mid - 1;\n      } else\n        lo = mid + 1;\n    }\n    if (an == -1) continue;\n    if (ans > cost + an * 1ll * p2) {\n      ans = cost + an * 1ll * p2;\n    }\n  }\n  if (ans == LLONG_MAX) ans = -1;\n  printf(\"%lld\\n\", ans);\n}\n",
                "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\ninline long long read() {\n  long long x = 0, w = 1;\n  char ch = 0;\n  while (ch < '0' || ch > '9') {\n    ch = getchar();\n    if (ch == '-') w = -1;\n  }\n  while (ch <= '9' && ch >= '0') {\n    x = (x << 1) + (x << 3) + ch - '0';\n    ch = getchar();\n  }\n  return x * w;\n}\ninline void chkmin(long long &x, long long y) {\n  if (x < 0 || (x > y && y >= 0)) x = y;\n}\nlong long n, T, t0, ans = -1;\nlong long a1, t1, p1;\nlong long a2, t2, p2;\ninline long long calc(long long cnt, long long tim) {\n  if (tim < 0) return -1;\n  if (cnt <= 0) return 0;\n  long long tot = cnt * t0;\n  if (tot <= tim) return 0;\n  if (t0 <= t2) return -1;\n  long long d = t0 - t2, t = tot - tim;\n  long long k = (t / d) + (t % d != 0);\n  if (k > cnt) return -1;\n  long long v = (k / a2) + (k % a2 != 0), res = v * p2;\n  return res;\n}\nint main() {\n  n = read(), T = read(), t0 = read();\n  a1 = read(), t1 = read(), p1 = read();\n  a2 = read(), t2 = read(), p2 = read();\n  for (long long i = 0;; ++i) {\n    long long w = i * p1, nowt = i * t1 * a1, nowc = i * a1;\n    if (nowc - a1 >= n) break;\n    long long k = calc(n - nowc, T - nowt);\n    if (k >= 0) chkmin(ans, k + w);\n  }\n  swap(t1, t2), swap(p1, p2), swap(a1, a2);\n  for (long long i = 0;; ++i) {\n    long long w = i * p1, nowt = i * t1 * a1, nowc = i * a1;\n    if (nowc - a1 >= n) break;\n    long long k = calc(n - nowc, T - nowt);\n    if (k >= 0) chkmin(ans, k + w);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
            ],
            "language": [
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2
            ]
        },
        "instruction": "Print the minimum amount of money that Polycarp needs to pay to download B++ compiler no more than in T milliseconds. If there is no solution, print the only integer -1.",
        "generate_testcase": "\nimport traceback\nfrom string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nimport random\nfrom typing import Tuple, Dict\n\ndef generate_testcase(json_obj: dict) -> Tuple[str, dict]:\n    \"\"\"\\n    Generate a test case for the download‑package problem.\\n\\n    The numeric scale values (file size f and package capacities a1, a2)\\n    are taken from the provided json_obj. All other parameters are\\n    generated randomly, respecting the problem limits and the additional\\n    requirement that generated values be < 10000. The generation is\\n    biased towards feasible instances (i.e., there exists at least one\\n    way to download the file within the time limit).\\n\\n    Returns:\\n        A tuple (input_string, data_dict) where:\\n            - input_string is the multiline input exactly as described\\n              in the statement.\\n            - data_dict is a dictionary with the same values.\\n    \"\"\"\n    # Required scale values\n    try:\n        f = int(json_obj[\"f\"])\n        a1 = int(json_obj[\"a1\"])\n        a2 = int(json_obj[\"a2\"])\n    except KeyError as e:\n        raise KeyError(f\"Missing required scale parameter: {e}\")\n\n    # Validate the given scale values\n    if not (1 <= f <= 10**7):\n        raise ValueError(\"f must satisfy 1 ≤ f ≤ 10^7\")\n    if not (1 <= a1 <= 10**7):\n        raise ValueError(\"a1 must satisfy 1 ≤ a1 ≤ 10^7\")\n    if not (1 <= a2 <= 10**7):\n        raise ValueError(\"a2 must satisfy 1 ≤ a2 ≤ 10^7\")\n\n    # Upper bound for any per‑byte time:\n    # - must be ≤ 10^7 / f to keep total time ≤ 10^7,\n    # - and also strictly < 10000 per the generation rule.\n    max_per_byte = min(9999, 10**7 // f)\n    if max_per_byte < 1:\n        # This can only happen when f > 10^7, which is prohibited by constraints.\n        max_per_byte = 1\n\n    # Random per‑byte times for the two packages\n    t1 = random.randint(1, max_per_byte)\n    t2 = random.randint(1, max_per_byte)\n\n    # Random package prices (strictly < 10000)\n    p1 = random.randint(1, 9999)\n    p2 = random.randint(1, 9999)\n\n    # Decide which kind of scenario to build:\n    #   • With probability 0.3 we make the regular tariff fast enough\n    #     → solution may cost 0.\n    #   • Otherwise we make the regular tariff slower so that packages\n    #     are needed.\n    if random.random() < 0.3:\n        # Scenario A: regular tariff can finish in time (zero‑cost possible)\n        fastest = min(t1, t2)\n        # t0 must be ≤ fastest (regular not slower)\n        t0 = random.randint(1, max(1, fastest))\n        # Choose any time limit that allows the regular tariff to finish\n        T_low = f * t0\n        T_high = 10**7\n        T = random.randint(T_low, T_high)\n    else:\n        # Scenario B: regular tariff too slow → packages are required\n        fastest = min(t1, t2)\n        # We need t0 > fastest, otherwise regular would be sufficient.\n        if fastest < max_per_byte:\n            t0 = random.randint(fastest + 1, max_per_byte)\n        else:\n            # Cannot make regular slower; fall back to scenario A\n            t0 = random.randint(1, max_per_byte)\n            fastest = t0  # now regular is fastest\n        # Time limit must be enough for the fastest package but not for regular\n        if t0 > fastest:\n            T_low = f * fastest\n            T_high = f * t0 - 1\n            T = random.randint(T_low, T_high)\n        else:\n            # Fallback to scenario A (regular works)\n            T_low = f * t0\n            T = random.randint(T_low, 10**7)\n\n    # Assemble the input string\n    input_str = f\"{f} {T} {t0}\\n{a1} {t1} {p1}\\n{a2} {t2} {p2}\"\n\n    # Assemble the dictionary representation\n    data_dict = {\n        \"f\": f,\n        \"T\": T,\n        \"t0\": t0,\n        \"a1\": a1,\n        \"t1\": t1,\n        \"p1\": p1,\n        \"a2\": a2,\n        \"t2\": t2,\n        \"p2\": p2,\n    }\n\n    return input_str, data_dict\n",
        "scale_range": 10000,
        "output_type": "number",
        "is_output_unique": true,
        "difficulty_dict": {
            "0": 0,
            "1": 2,
            "2": 3,
            "3": 4,
            "4": 7,
            "5": 10,
            "6": 17,
            "7": 27,
            "8": 43,
            "9": 69,
            "10": 110,
            "11": 176,
            "12": 281,
            "13": 450,
            "14": 721,
            "15": 1153,
            "16": 1845,
            "17": 2951,
            "18": 4722,
            "19": 7556,
            "20": 10000
        },
        "params": {
            "f": {
                "min": 1,
                "max": 10001,
                "base": 1.0
            },
            "a1": {
                "min": 1,
                "max": 10001,
                "base": 1.0
            },
            "a2": {
                "min": 1,
                "max": 10001,
                "base": 1.0
            },
            "difficulty": {
                "version": 1,
                "params": {
                    "dmax": 20,
                    "ema_beta": 0.0,
                    "activate_function": "base",
                    "history_len": 20,
                    "slope_scale": 0.05,
                    "age_scale": 100,
                    "alpha": 1.0,
                    "beta": 0.1
                }
            }
        }
    }
}